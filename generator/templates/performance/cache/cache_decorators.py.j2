"""
Cache decorators for {{ project.name }}.

Generated by Django Enhanced Generator on {{ now().strftime('%Y-%m-%d %H:%M:%S') }}.
"""
from functools import wraps
from django.core.cache import cache
from django.core.cache.utils import make_template_fragment_key
from django.http import HttpResponse
from django.utils.decorators import available_attrs
from django.views.decorators.vary import vary_on_headers
import hashlib
import json
import logging
from typing import Any, Callable, Optional, List, Union

logger = logging.getLogger(__name__)


def cache_result(timeout: int = 3600, key_prefix: Optional[str] = None, vary_on: Optional[List[str]] = None):
    """
    Decorator to cache function results.
    
    Args:
        timeout: Cache timeout in seconds
        key_prefix: Prefix for cache key
        vary_on: List of arguments to vary cache on
    """
    def decorator(func: Callable) -> Callable:
        @wraps(func, assigned=available_attrs(func))
        def wrapper(*args, **kwargs):
            # Generate cache key
            cache_key_parts = [key_prefix or func.__name__]
            
            # Add specific arguments to cache key
            if vary_on:
                for arg_name in vary_on:
                    if arg_name in kwargs:
                        cache_key_parts.append(f"{arg_name}:{kwargs[arg_name]}")
            else:
                # Add all args and kwargs to key
                for arg in args:
                    if hasattr(arg, 'pk'):
                        cache_key_parts.append(f"pk:{arg.pk}")
                    elif hasattr(arg, 'id'):
                        cache_key_parts.append(f"id:{arg.id}")
                    else:
                        cache_key_parts.append(str(arg)[:50])  # Limit length
                
                for k, v in sorted(kwargs.items()):
                    cache_key_parts.append(f"{k}:{str(v)[:50]}")
            
            # Create hash of cache key to ensure consistent length
            cache_key_string = ":".join(cache_key_parts)
            cache_key = hashlib.md5(cache_key_string.encode()).hexdigest()
            
            # Try to get from cache
            result = cache.get(cache_key)
            if result is not None:
                logger.debug(f"Cache hit for key: {cache_key}")
                return result
            
            # Compute and cache result
            result = func(*args, **kwargs)
            cache.set(cache_key, result, timeout)
            logger.debug(f"Cache set for key: {cache_key}")
            
            return result
        
        # Add cache invalidation method
        def invalidate(*args, **kwargs):
            """Invalidate cache for this function."""
            cache_key_parts = [key_prefix or func.__name__]
            
            if vary_on:
                for arg_name in vary_on:
                    if arg_name in kwargs:
                        cache_key_parts.append(f"{arg_name}:{kwargs[arg_name]}")
            
            cache_key_string = ":".join(cache_key_parts)
            cache_key = hashlib.md5(cache_key_string.encode()).hexdigest()
            cache.delete(cache_key)
            logger.debug(f"Cache invalidated for key: {cache_key}")
        
        wrapper.invalidate = invalidate
        wrapper._cache_timeout = timeout
        wrapper._cache_key_prefix = key_prefix
        
        return wrapper
    
    return decorator


def cache_page_conditional(timeout: int = 3600, condition: Optional[Callable] = None, key_func: Optional[Callable] = None):
    """
    Conditional page caching decorator.
    
    Args:
        timeout: Cache timeout in seconds
        condition: Function to determine if caching should be applied
        key_func: Function to generate cache key
    """
    def decorator(view_func: Callable) -> Callable:
        @wraps(view_func, assigned=available_attrs(view_func))
        def wrapper(request, *args, **kwargs):
            # Check condition
            if condition and not condition(request):
                return view_func(request, *args, **kwargs)
            
            # Generate cache key
            if key_func:
                cache_key = key_func(request, *args, **kwargs)
            else:
                cache_key_parts = [
                    request.path,
                    request.method,
                    str(sorted(request.GET.items())),
                ]
                if request.user.is_authenticated:
                    cache_key_parts.append(f"user:{request.user.id}")
                
                cache_key = hashlib.md5(":".join(cache_key_parts).encode()).hexdigest()
            
            # Try to get from cache
            response = cache.get(cache_key)
            if response is not None:
                logger.debug(f"Page cache hit for: {request.path}")
                return response
            
            # Generate response
            response = view_func(request, *args, **kwargs)
            
            # Cache successful responses
            if isinstance(response, HttpResponse) and response.status_code == 200:
                cache.set(cache_key, response, timeout)
                logger.debug(f"Page cached for: {request.path}")
            
            return response
        
        return wrapper
    
    return decorator


def cache_model_method(timeout: int = 3600, key_attr: str = 'pk'):
    """
    Cache model method results.
    
    Args:
        timeout: Cache timeout in seconds
        key_attr: Model attribute to use in cache key
    """
    def decorator(method: Callable) -> Callable:
        @wraps(method, assigned=available_attrs(method))
        def wrapper(self, *args, **kwargs):
            # Generate cache key
            model_name = self.__class__.__name__
            instance_key = getattr(self, key_attr)
            method_name = method.__name__
            
            cache_key_parts = [model_name, str(instance_key), method_name]
            
            # Add method arguments to key
            for arg in args:
                cache_key_parts.append(str(arg)[:50])
            
            for k, v in sorted(kwargs.items()):
                cache_key_parts.append(f"{k}:{str(v)[:50]}")
            
            cache_key = hashlib.md5(":".join(cache_key_parts).encode()).hexdigest()
            
            # Try to get from cache
            result = cache.get(cache_key)
            if result is not None:
                return result
            
            # Compute and cache result
            result = method(self, *args, **kwargs)
            cache.set(cache_key, result, timeout)
            
            return result
        
        return wrapper
    
    return decorator


def cache_queryset(timeout: int = 1800, key_prefix: Optional[str] = None):
    """
    Cache queryset results.
    
    Args:
        timeout: Cache timeout in seconds
        key_prefix: Prefix for cache key
    """
    def decorator(method: Callable) -> Callable:
        @wraps(method, assigned=available_attrs(method))
        def wrapper(*args, **kwargs):
            # Generate cache key from queryset
            cache_key_parts = [key_prefix or method.__name__]
            
            # Add method arguments
            for arg in args:
                if hasattr(arg, '__class__'):
                    cache_key_parts.append(arg.__class__.__name__)
                else:
                    cache_key_parts.append(str(arg)[:50])
            
            for k, v in sorted(kwargs.items()):
                cache_key_parts.append(f"{k}:{str(v)[:50]}")
            
            cache_key = hashlib.md5(":".join(cache_key_parts).encode()).hexdigest()
            
            # Try to get from cache
            result = cache.get(cache_key)
            if result is not None:
                return result
            
            # Execute queryset and cache results
            queryset = method(*args, **kwargs)
            
            # Convert to list to cache
            if hasattr(queryset, 'all'):
                result = list(queryset)
            else:
                result = queryset
            
            cache.set(cache_key, result, timeout)
            
            return result
        
        return wrapper
    
    return decorator


def cache_template_fragment(fragment_name: str, timeout: int = 3600, vary_on: Optional[List[str]] = None):
    """
    Cache template fragments.
    
    Args:
        fragment_name: Name of the template fragment
        timeout: Cache timeout in seconds
        vary_on: List of variables to vary cache on
    """
    def decorator(view_func: Callable) -> Callable:
        @wraps(view_func, assigned=available_attrs(view_func))
        def wrapper(request, *args, **kwargs):
            # Generate vary_on values
            vary_values = []
            if vary_on:
                for vary_key in vary_on:
                    if vary_key == 'user':
                        vary_values.append(request.user.id if request.user.is_authenticated else 'anonymous')
                    elif vary_key == 'language':
                        vary_values.append(getattr(request, 'LANGUAGE_CODE', 'en'))
                    elif hasattr(request, vary_key):
                        vary_values.append(str(getattr(request, vary_key)))
                    elif vary_key in request.GET:
                        vary_values.append(request.GET[vary_key])
            
            # Generate fragment cache key
            fragment_key = make_template_fragment_key(fragment_name, vary_values)
            
            # Try to get from cache
            cached_content = cache.get(fragment_key)
            if cached_content is not None:
                return cached_content
            
            # Generate content
            response = view_func(request, *args, **kwargs)
            
            # Cache the response content
            if hasattr(response, 'content'):
                cache.set(fragment_key, response.content, timeout)
            
            return response
        
        return wrapper
    
    return decorator


def invalidate_cache_on_save(cache_keys: Union[str, List[str]], timeout: Optional[int] = None):
    """
    Invalidate cache when model is saved.
    
    Args:
        cache_keys: Cache key(s) to invalidate
        timeout: Optional new timeout for cache
    """
    def decorator(save_method: Callable) -> Callable:
        @wraps(save_method, assigned=available_attrs(save_method))
        def wrapper(self, *args, **kwargs):
            # Call original save method
            result = save_method(self, *args, **kwargs)
            
            # Invalidate cache keys
            keys_to_invalidate = cache_keys if isinstance(cache_keys, list) else [cache_keys]
            
            for key_pattern in keys_to_invalidate:
                # Replace placeholders with actual values
                cache_key = key_pattern.format(
                    pk=self.pk,
                    id=self.id if hasattr(self, 'id') else self.pk,
                    model=self.__class__.__name__.lower(),
                )
                
                cache.delete(cache_key)
                logger.debug(f"Cache invalidated: {cache_key}")
            
            return result
        
        return wrapper
    
    return decorator


# Utility functions
def warm_cache(cache_key: str, compute_func: Callable, timeout: int = 3600, *args, **kwargs):
    """
    Warm cache with computed value.
    
    Args:
        cache_key: Cache key to warm
        compute_func: Function to compute the value
        timeout: Cache timeout
        *args, **kwargs: Arguments for compute function
    """
    try:
        value = compute_func(*args, **kwargs)
        cache.set(cache_key, value, timeout)
        logger.info(f"Cache warmed for key: {cache_key}")
        return value
    except Exception as e:
        logger.error(f"Failed to warm cache for key {cache_key}: {e}")
        return None


def cache_many(key_value_pairs: dict, timeout: int = 3600):
    """
    Cache multiple key-value pairs at once.
    
    Args:
        key_value_pairs: Dictionary of cache keys and values
        timeout: Cache timeout
    """
    try:
        cache.set_many(key_value_pairs, timeout)
        logger.debug(f"Cached {len(key_value_pairs)} items")
    except Exception as e:
        logger.error(f"Failed to cache multiple items: {e}")


def get_or_set_cache(cache_key: str, compute_func: Callable, timeout: int = 3600, *args, **kwargs):
    """
    Get from cache or compute and set.
    
    Args:
        cache_key: Cache key
        compute_func: Function to compute value if not in cache
        timeout: Cache timeout
        *args, **kwargs: Arguments for compute function
    """
    value = cache.get(cache_key)
    if value is None:
        value = compute_func(*args, **kwargs)
        cache.set(cache_key, value, timeout)
    
    return value