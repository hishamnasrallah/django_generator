"""
Prometheus monitoring for {{ project.name }}.

Generated by Django Enhanced Generator on {{ now().strftime('%Y-%m-%d %H:%M:%S') }}.
"""
from prometheus_client import Counter, Histogram, Gauge, Info, generate_latest
from django.http import HttpResponse
from django.views import View
from django.contrib.auth import get_user_model
from django.db import connection
from django.core.cache import cache
import time
import psutil
import logging

logger = logging.getLogger(__name__)

User = get_user_model()

# Application metrics
django_requests_total = Counter(
    'django_requests_total',
    'Total Django requests',
    ['method', 'endpoint', 'status_code']
)

django_request_duration_seconds = Histogram(
    'django_request_duration_seconds',
    'Django request duration',
    ['method', 'endpoint']
)

django_active_users = Gauge(
    'django_active_users',
    'Number of active users'
)

django_database_connections = Gauge(
    'django_database_connections',
    'Number of database connections'
)

django_cache_operations_total = Counter(
    'django_cache_operations_total',
    'Total cache operations',
    ['operation', 'result']
)

# Model-specific metrics
{% for app in apps %}
{% for model in app.models %}
{{ app.name }}_{{ model.name|lower }}_total = Gauge(
    '{{ app.name }}_{{ model.name|lower }}_total',
    'Total number of {{ model.name }} objects',
    ['status']
)

{{ app.name }}_{{ model.name|lower }}_operations_total = Counter(
    '{{ app.name }}_{{ model.name|lower }}_operations_total',
    'Total {{ model.name }} operations',
    ['operation', 'status']
)

{% endfor %}
{% endfor %}

# System metrics
system_cpu_usage = Gauge(
    'system_cpu_usage_percent',
    'System CPU usage percentage'
)

system_memory_usage = Gauge(
    'system_memory_usage_bytes',
    'System memory usage in bytes'
)

system_disk_usage = Gauge(
    'system_disk_usage_percent',
    'System disk usage percentage'
)

# Application info
app_info = Info(
    'django_app_info',
    'Django application information'
)

# Set application info
app_info.info({
    'version': '{{ project.version|default("1.0.0") }}',
    'name': '{{ project.name }}',
    'environment': 'development',  # This should be set from environment
})


class PrometheusMetricsMiddleware:
    """Middleware to collect Prometheus metrics."""
    
    def __init__(self, get_response):
        self.get_response = get_response
    
    def __call__(self, request):
        start_time = time.time()
        
        response = self.get_response(request)
        
        # Record metrics
        duration = time.time() - start_time
        
        django_requests_total.labels(
            method=request.method,
            endpoint=self._get_endpoint(request),
            status_code=response.status_code
        ).inc()
        
        django_request_duration_seconds.labels(
            method=request.method,
            endpoint=self._get_endpoint(request)
        ).observe(duration)
        
        return response
    
    def _get_endpoint(self, request):
        """Get normalized endpoint name."""
        path = request.path
        
        # Remove IDs and other dynamic parts
        import re
        path = re.sub(r'/\d+/', '/{id}/', path)
        path = re.sub(r'/[a-f0-9-]{36}/', '/{uuid}/', path)  # UUIDs
        
        return path


class MetricsCollector:
    """Collects various application metrics."""
    
    @staticmethod
    def collect_user_metrics():
        """Collect user-related metrics."""
        try:
            # Active users (logged in within last 24 hours)
            from datetime import datetime, timedelta
            from django.utils import timezone
            
            cutoff = timezone.now() - timedelta(hours=24)
            active_count = User.objects.filter(last_login__gte=cutoff).count()
            django_active_users.set(active_count)
            
        except Exception as e:
            logger.error(f"Failed to collect user metrics: {e}")
    
    @staticmethod
    def collect_database_metrics():
        """Collect database-related metrics."""
        try:
            # Database connections
            with connection.cursor() as cursor:
                cursor.execute("SELECT count(*) FROM pg_stat_activity;")
                conn_count = cursor.fetchone()[0]
                django_database_connections.set(conn_count)
                
        except Exception as e:
            logger.error(f"Failed to collect database metrics: {e}")
    
    @staticmethod
    def collect_cache_metrics():
        """Collect cache-related metrics."""
        try:
            # Test cache operation
            test_key = 'prometheus_test'
            cache.set(test_key, 'test', 1)
            result = cache.get(test_key)
            
            if result:
                django_cache_operations_total.labels(
                    operation='test',
                    result='hit'
                ).inc()
            else:
                django_cache_operations_total.labels(
                    operation='test',
                    result='miss'
                ).inc()
                
        except Exception as e:
            logger.error(f"Failed to collect cache metrics: {e}")
    
    @staticmethod
    def collect_model_metrics():
        """Collect model-specific metrics."""
        {% for app in apps %}
        {% for model in app.models %}
        try:
            from apps.{{ app.name }}.models import {{ model.name }}
            
            # Total count
            total_count = {{ model.name }}.objects.count()
            {{ app.name }}_{{ model.name|lower }}_total.labels(status='total').set(total_count)
            
            # Count by status if status field exists
            {% for field in model.fields %}
            {% if field.name == 'status' %}
            status_counts = {{ model.name }}.objects.values('status').annotate(
                count=models.Count('id')
            )
            for item in status_counts:
                {{ app.name }}_{{ model.name|lower }}_total.labels(
                    status=item['status']
                ).set(item['count'])
            {% endif %}
            {% endfor %}
            
        except Exception as e:
            logger.error(f"Failed to collect {{ model.name }} metrics: {e}")
        
        {% endfor %}
        {% endfor %}
    
    @staticmethod
    def collect_system_metrics():
        """Collect system-level metrics."""
        try:
            # CPU usage
            cpu_percent = psutil.cpu_percent(interval=1)
            system_cpu_usage.set(cpu_percent)
            
            # Memory usage
            memory = psutil.virtual_memory()
            system_memory_usage.set(memory.used)
            
            # Disk usage
            disk = psutil.disk_usage('/')
            disk_percent = (disk.used / disk.total) * 100
            system_disk_usage.set(disk_percent)
            
        except Exception as e:
            logger.error(f"Failed to collect system metrics: {e}")
    
    @classmethod
    def collect_all_metrics(cls):
        """Collect all metrics."""
        cls.collect_user_metrics()
        cls.collect_database_metrics()
        cls.collect_cache_metrics()
        cls.collect_model_metrics()
        cls.collect_system_metrics()


class MetricsView(View):
    """View to expose Prometheus metrics."""
    
    def get(self, request):
        """Return Prometheus metrics."""
        # Collect latest metrics
        MetricsCollector.collect_all_metrics()
        
        # Generate metrics output
        metrics_output = generate_latest()
        
        return HttpResponse(
            metrics_output,
            content_type='text/plain; charset=utf-8'
        )


# Utility functions for custom metrics
def record_model_operation(app_name: str, model_name: str, operation: str, status: str = 'success'):
    """Record a model operation metric."""
    try:
        metric_name = f"{app_name}_{model_name.lower()}_operations_total"
        metric = globals().get(metric_name)
        
        if metric:
            metric.labels(operation=operation, status=status).inc()
        
    except Exception as e:
        logger.error(f"Failed to record model operation metric: {e}")


def record_cache_operation(operation: str, result: str):
    """Record a cache operation metric."""
    try:
        django_cache_operations_total.labels(
            operation=operation,
            result=result
        ).inc()
        
    except Exception as e:
        logger.error(f"Failed to record cache operation metric: {e}")


def time_function(metric_name: str, labels: dict = None):
    """Decorator to time function execution."""
    def decorator(func):
        def wrapper(*args, **kwargs):
            start_time = time.time()
            
            try:
                result = func(*args, **kwargs)
                status = 'success'
            except Exception as e:
                status = 'error'
                raise
            finally:
                duration = time.time() - start_time
                
                # Record timing metric
                metric = globals().get(metric_name)
                if metric and hasattr(metric, 'labels'):
                    metric_labels = labels or {}
                    metric_labels['status'] = status
                    metric.labels(**metric_labels).observe(duration)
            
            return result
        
        return wrapper
    
    return decorator


# Health check metrics
health_check_status = Gauge(
    'django_health_check_status',
    'Health check status (1 = healthy, 0 = unhealthy)',
    ['check_name']
)


def record_health_check(check_name: str, is_healthy: bool):
    """Record health check status."""
    health_check_status.labels(check_name=check_name).set(1 if is_healthy else 0)