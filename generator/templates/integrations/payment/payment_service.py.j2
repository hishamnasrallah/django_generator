"""
Payment service for {{ project.name }}.

Generated by Django Enhanced Generator on {{ now().strftime('%Y-%m-%d %H:%M:%S') }}.
"""
from abc import ABC, abstractmethod
from decimal import Decimal
from typing import Dict, Any, Optional, List
from django.conf import settings
from django.core.exceptions import ImproperlyConfigured
import logging

logger = logging.getLogger(__name__)


class PaymentError(Exception):
    """Base exception for payment errors."""
    pass


class PaymentGatewayError(PaymentError):
    """Exception for payment gateway errors."""
    pass


class PaymentValidationError(PaymentError):
    """Exception for payment validation errors."""
    pass


class PaymentGateway(ABC):
    """Abstract base class for payment gateways."""
    
    @abstractmethod
    def create_payment(self, amount: Decimal, currency: str, description: str, 
                      metadata: Dict[str, Any]) -> Dict[str, Any]:
        """Create a payment intent/order."""
        pass
    
    @abstractmethod
    def capture_payment(self, payment_id: str, amount: Optional[Decimal] = None) -> Dict[str, Any]:
        """Capture a previously authorized payment."""
        pass
    
    @abstractmethod
    def refund_payment(self, payment_id: str, amount: Optional[Decimal] = None, 
                      reason: Optional[str] = None) -> Dict[str, Any]:
        """Refund a payment."""
        pass
    
    @abstractmethod
    def get_payment_status(self, payment_id: str) -> str:
        """Get current payment status."""
        pass
    
    @abstractmethod
    def handle_webhook(self, payload: Dict[str, Any], signature: str) -> Dict[str, Any]:
        """Handle webhook from payment provider."""
        pass


class PaymentService:
    """Unified payment service that manages multiple gateways."""
    
    def __init__(self):
        self.gateways = {}
        self.default_gateway = None
        self._load_gateways()
    
    def _load_gateways(self):
        """Load configured payment gateways."""
        payment_config = getattr(settings, 'PAYMENT_GATEWAYS', {})
        
        for gateway_name, config in payment_config.items():
            try:
                gateway_class = self._import_gateway_class(config['class'])
                gateway = gateway_class(**config.get('options', {}))
                self.gateways[gateway_name] = gateway
                
                if config.get('default', False):
                    self.default_gateway = gateway_name
                    
                logger.info(f"Loaded payment gateway: {gateway_name}")
                
            except Exception as e:
                logger.error(f"Failed to load payment gateway {gateway_name}: {e}")
        
        if not self.default_gateway and self.gateways:
            self.default_gateway = list(self.gateways.keys())[0]
    
    def _import_gateway_class(self, class_path: str):
        """Import gateway class from string path."""
        module_path, class_name = class_path.rsplit('.', 1)
        module = __import__(module_path, fromlist=[class_name])
        return getattr(module, class_name)
    
    def get_gateway(self, gateway_name: Optional[str] = None) -> PaymentGateway:
        """Get payment gateway by name."""
        gateway_name = gateway_name or self.default_gateway
        
        if not gateway_name or gateway_name not in self.gateways:
            raise PaymentGatewayError(f"Payment gateway '{gateway_name}' not found")
        
        return self.gateways[gateway_name]
    
    def create_payment(self, amount: Decimal, currency: str = 'USD', 
                      description: str = '', metadata: Optional[Dict[str, Any]] = None,
                      gateway: Optional[str] = None) -> 'Payment':
        """
        Create a new payment.
        
        Args:
            amount: Payment amount
            currency: Currency code
            description: Payment description
            metadata: Additional metadata
            gateway: Gateway to use (defaults to default gateway)
            
        Returns:
            Payment instance
        """
        from .models import Payment
        
        # Validate amount
        if amount <= 0:
            raise PaymentValidationError("Payment amount must be positive")
        
        # Get gateway
        payment_gateway = self.get_gateway(gateway)
        gateway_name = gateway or self.default_gateway
        
        # Create payment record
        payment = Payment.objects.create(
            amount=amount,
            currency=currency,
            description=description,
            gateway=gateway_name,
            status='pending',
            metadata=metadata or {}
        )
        
        try:
            # Create payment with gateway
            gateway_response = payment_gateway.create_payment(
                amount=amount,
                currency=currency,
                description=description,
                metadata={
                    'payment_id': payment.id,
                    **(metadata or {})
                }
            )
            
            # Update payment with gateway response
            payment.gateway_payment_id = gateway_response.get('payment_id')
            payment.gateway_response = gateway_response
            payment.status = gateway_response.get('status', 'pending')
            payment.save()
            
            logger.info(f"Payment created: {payment.id} via {gateway_name}")
            
            return payment
            
        except Exception as e:
            payment.status = 'failed'
            payment.error_message = str(e)
            payment.save()
            
            logger.error(f"Payment creation failed: {payment.id} - {e}")
            raise PaymentGatewayError(f"Failed to create payment: {e}")
    
    def capture_payment(self, payment_id: int, amount: Optional[Decimal] = None) -> bool:
        """
        Capture a payment.
        
        Args:
            payment_id: Payment ID
            amount: Amount to capture (defaults to full amount)
            
        Returns:
            True if successful
        """
        from .models import Payment
        
        try:
            payment = Payment.objects.get(id=payment_id)
            
            if payment.status != 'authorized':
                raise PaymentValidationError(f"Payment {payment_id} is not authorized")
            
            gateway = self.get_gateway(payment.gateway)
            
            # Capture with gateway
            gateway_response = gateway.capture_payment(
                payment.gateway_payment_id,
                amount or payment.amount
            )
            
            # Update payment
            payment.status = gateway_response.get('status', 'captured')
            payment.captured_amount = gateway_response.get('captured_amount', amount or payment.amount)
            payment.gateway_response.update(gateway_response)
            payment.save()
            
            logger.info(f"Payment captured: {payment_id}")
            
            return True
            
        except Payment.DoesNotExist:
            raise PaymentValidationError(f"Payment {payment_id} not found")
        except Exception as e:
            logger.error(f"Payment capture failed: {payment_id} - {e}")
            raise PaymentGatewayError(f"Failed to capture payment: {e}")
    
    def refund_payment(self, payment_id: int, amount: Optional[Decimal] = None, 
                      reason: Optional[str] = None) -> bool:
        """
        Refund a payment.
        
        Args:
            payment_id: Payment ID
            amount: Amount to refund (defaults to full amount)
            reason: Refund reason
            
        Returns:
            True if successful
        """
        from .models import Payment, Refund
        
        try:
            payment = Payment.objects.get(id=payment_id)
            
            if payment.status not in ['captured', 'succeeded']:
                raise PaymentValidationError(f"Payment {payment_id} cannot be refunded")
            
            refund_amount = amount or payment.amount
            
            # Check if refund amount is valid
            total_refunded = payment.refunds.aggregate(
                total=models.Sum('amount')
            )['total'] or Decimal('0')
            
            if total_refunded + refund_amount > payment.amount:
                raise PaymentValidationError("Refund amount exceeds payment amount")
            
            gateway = self.get_gateway(payment.gateway)
            
            # Process refund with gateway
            gateway_response = gateway.refund_payment(
                payment.gateway_payment_id,
                refund_amount,
                reason
            )
            
            # Create refund record
            refund = Refund.objects.create(
                payment=payment,
                amount=refund_amount,
                reason=reason or 'Customer request',
                gateway_refund_id=gateway_response.get('refund_id'),
                gateway_response=gateway_response,
                status=gateway_response.get('status', 'pending')
            )
            
            # Update payment status if fully refunded
            if total_refunded + refund_amount >= payment.amount:
                payment.status = 'refunded'
                payment.save()
            
            logger.info(f"Payment refunded: {payment_id} - {refund_amount}")
            
            return True
            
        except Payment.DoesNotExist:
            raise PaymentValidationError(f"Payment {payment_id} not found")
        except Exception as e:
            logger.error(f"Payment refund failed: {payment_id} - {e}")
            raise PaymentGatewayError(f"Failed to refund payment: {e}")
    
    def handle_webhook(self, gateway_name: str, payload: Dict[str, Any], 
                      signature: str) -> Dict[str, Any]:
        """
        Handle webhook from payment gateway.
        
        Args:
            gateway_name: Name of the gateway
            payload: Webhook payload
            signature: Webhook signature
            
        Returns:
            Processing result
        """
        try:
            gateway = self.get_gateway(gateway_name)
            result = gateway.handle_webhook(payload, signature)
            
            logger.info(f"Webhook processed: {gateway_name}")
            
            return result
            
        except Exception as e:
            logger.error(f"Webhook processing failed: {gateway_name} - {e}")
            raise PaymentGatewayError(f"Failed to process webhook: {e}")
    
    def get_payment_methods(self, gateway_name: Optional[str] = None) -> List[Dict[str, Any]]:
        """
        Get available payment methods.
        
        Args:
            gateway_name: Gateway to get methods for
            
        Returns:
            List of payment methods
        """
        gateway = self.get_gateway(gateway_name)
        
        if hasattr(gateway, 'get_payment_methods'):
            return gateway.get_payment_methods()
        
        return []
    
    def validate_payment_data(self, payment_data: Dict[str, Any]) -> bool:
        """
        Validate payment data.
        
        Args:
            payment_data: Payment data to validate
            
        Returns:
            True if valid
        """
        required_fields = ['amount', 'currency']
        
        for field in required_fields:
            if field not in payment_data:
                raise PaymentValidationError(f"Missing required field: {field}")
        
        # Validate amount
        try:
            amount = Decimal(str(payment_data['amount']))
            if amount <= 0:
                raise PaymentValidationError("Amount must be positive")
        except (ValueError, TypeError):
            raise PaymentValidationError("Invalid amount format")
        
        # Validate currency
        currency = payment_data['currency'].upper()
        if len(currency) != 3:
            raise PaymentValidationError("Invalid currency code")
        
        return True


# Global payment service instance
payment_service = PaymentService()