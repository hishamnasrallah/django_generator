"""
WebSocket consumers for {{ app_name }} app.

Generated by Django Enhanced Generator on {{ now().strftime('%Y-%m-%d %H:%M:%S') }}.
"""
import json
import logging
from channels.generic.websocket import AsyncJsonWebsocketConsumer
from channels.db import database_sync_to_async
from django.contrib.auth.models import AnonymousUser
from django.contrib.auth import get_user_model
from django.core.serializers import serialize
from django.apps import apps
{% for model in models %}
from ..models import {{ model.name }}
{% endfor %}

logger = logging.getLogger(__name__)
User = get_user_model()


class BaseConsumer(AsyncJsonWebsocketConsumer):
    """Base WebSocket consumer with common functionality."""
    
    async def connect(self):
        """Handle WebSocket connection."""
        # Check authentication
        if self.scope["user"] == AnonymousUser():
            await self.close(code=4001)  # Unauthorized
            return
        
        # Join room group
        await self.channel_layer.group_add(
            self.room_group_name,
            self.channel_name
        )
        
        await self.accept()
        
        # Send connection confirmation
        await self.send_json({
            'type': 'connection.established',
            'message': f'Connected to {self.room_group_name}'
        })
        
        logger.info(
            f"User {self.scope['user'].id} connected to {self.room_group_name}"
        )
    
    async def disconnect(self, close_code):
        """Handle WebSocket disconnection."""
        # Leave room group
        await self.channel_layer.group_discard(
            self.room_group_name,
            self.channel_name
        )
        
        logger.info(
            f"User {self.scope['user'].id if self.scope['user'] != AnonymousUser() else 'anonymous'} "
            f"disconnected from {self.room_group_name} with code {close_code}"
        )
    
    async def receive_json(self, content):
        """Handle incoming WebSocket messages."""
        action = content.get('action')
        
        if action == 'subscribe':
            await self.handle_subscribe(content.get('filters', {}))
        elif action == 'unsubscribe':
            await self.handle_unsubscribe()
        elif action == 'ping':
            await self.send_json({'type': 'pong'})
        else:
            await self.send_json({
                'type': 'error',
                'message': f'Unknown action: {action}'
            })
    
    async def handle_subscribe(self, filters):
        """Handle subscription with filters."""
        # Store filters for this connection
        self.filters = filters
        
        await self.send_json({
            'type': 'subscription.confirmed',
            'filters': filters
        })
    
    async def handle_unsubscribe(self):
        """Handle unsubscription."""
        self.filters = {}
        
        await self.send_json({
            'type': 'subscription.cancelled'
        })
    
    def matches_filters(self, data):
        """Check if data matches subscription filters."""
        if not hasattr(self, 'filters') or not self.filters:
            return True
        
        for key, value in self.filters.items():
            if key in data and data[key] != value:
                return False
        
        return True


{% for consumer in consumers %}
class {{ consumer.name }}(BaseConsumer):
    """
    WebSocket consumer for {{ consumer.model_name }} real-time updates.
    
    Handles:
    {% for event in consumer.events %}
    - {{ event }}
    {% endfor %}
    """
    
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.room_group_name = '{{ consumer.room_name }}'
        self.model_name = '{{ consumer.model_name }}'
    
    async def connect(self):
        """Handle connection with permission checks."""
        # Check model-level permissions
        user = self.scope["user"]
        if user == AnonymousUser():
            await self.close(code=4001)
            return
        
        {% if consumer.permissions %}
        # Check specific permissions
        has_permission = await self.check_permissions(user)
        if not has_permission:
            await self.close(code=4003)  # Forbidden
            return
        {% endif %}
        
        await super().connect()
    
    {% if consumer.permissions %}
    @database_sync_to_async
    def check_permissions(self, user):
        """Check if user has required permissions."""
        required_perms = {{ consumer.permissions }}
        
        for perm in required_perms:
            if not user.has_perm(perm):
                return False
        
        return True
    {% endif %}
    
    # Event handlers
    {% for event in consumer.events %}
    async def {{ event }}(self, event):
        """Handle {{ event }} event."""
        data = event['data']
        
        # Check if this update matches user's filters
        if not self.matches_filters(data):
            return
        
        # Send update to WebSocket
        await self.send_json({
            'type': '{{ event }}',
            'data': data,
            'timestamp': event.get('timestamp')
        })
    {% endfor %}
    
    @database_sync_to_async
    def get_model_data(self, instance_id):
        """Get serialized model data."""
        try:
            instance = {{ consumer.model_name }}.objects.get(pk=instance_id)
            
            # Basic serialization
            data = {
                'id': instance.pk,
                {% for field in models|selectattr('name', 'equalto', consumer.model_name)|first|attr('fields') %}
                {% if field.type not in ['ForeignKey', 'OneToOneField', 'ManyToManyField'] %}
                '{{ field.name }}': getattr(instance, '{{ field.name }}', None),
                {% endif %}
                {% endfor %}
            }
            
            # Add related data if needed
            {% for field in models|selectattr('name', 'equalto', consumer.model_name)|first|attr('fields') %}
            {% if field.type == 'ForeignKey' %}
            if hasattr(instance, '{{ field.name }}') and instance.{{ field.name }}:
                data['{{ field.name }}_id'] = instance.{{ field.name }}.pk
            {% endif %}
            {% endfor %}
            
            return data
            
        except {{ consumer.model_name }}.DoesNotExist:
            return None


{% endfor %}

# Notification consumer for general notifications
class NotificationConsumer(BaseConsumer):
    """Consumer for general user notifications."""
    
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.room_group_name = f"user_{self.scope['user'].id}_notifications"
    
    async def connect(self):
        """Connect to user's notification channel."""
        if self.scope["user"] == AnonymousUser():
            await self.close(code=4001)
            return
        
        await super().connect()
    
    async def notification_message(self, event):
        """Handle notification messages."""
        await self.send_json({
            'type': 'notification',
            'data': event['data']
        })


# Broadcast helper functions
async def broadcast_model_update(model_name, instance_id, event_type, user=None):
    """
    Broadcast model update to WebSocket consumers.
    
    Args:
        model_name: Name of the model
        instance_id: ID of the instance
        event_type: Type of event (created, updated, deleted)
        user: User who triggered the event
    """
    from channels.layers import get_channel_layer
    
    channel_layer = get_channel_layer()
    room_name = f"{model_name.lower()}_updates"
    
    # Get model data
    if event_type != 'deleted':
        model_class = apps.get_model('{{ app_name }}', model_name)
        try:
            instance = await database_sync_to_async(model_class.objects.get)(pk=instance_id)
            data = await database_sync_to_async(serialize_instance)(instance)
        except model_class.DoesNotExist:
            data = {'id': instance_id}
    else:
        data = {'id': instance_id}
    
    # Add metadata
    data.update({
        'event_type': event_type,
        'user_id': user.id if user else None,
        'timestamp': timezone.now().isoformat()
    })
    
    # Broadcast to group
    await channel_layer.group_send(
        room_name,
        {
            'type': f'model_{event_type}',
            'data': data
        }
    )


def serialize_instance(instance):
    """Serialize model instance to dict."""
    data = {}
    
    for field in instance._meta.fields:
        value = getattr(instance, field.name)
        
        # Handle different field types
        if hasattr(value, 'isoformat'):  # DateTime fields
            data[field.name] = value.isoformat()
        elif hasattr(value, '__str__'):
            data[field.name] = str(value)
        else:
            data[field.name] = value
    
    return data


# Signal handlers for automatic broadcasting
from django.db.models.signals import post_save, post_delete
from django.dispatch import receiver
from asgiref.sync import async_to_sync
from channels.layers import get_channel_layer

{% for model in models %}
@receiver(post_save, sender={{ model.name }})
def {{ model.name.lower() }}_post_save(sender, instance, created, **kwargs):
    """Broadcast {{ model.name }} save events."""
    event_type = 'created' if created else 'updated'
    
    # Get user from thread local if available
    user = getattr(instance, '_current_user', None)
    
    # Broadcast asynchronously
    async_to_sync(broadcast_model_update)(
        '{{ model.name }}',
        instance.pk,
        event_type,
        user
    )


@receiver(post_delete, sender={{ model.name }})
def {{ model.name.lower() }}_post_delete(sender, instance, **kwargs):
    """Broadcast {{ model.name }} delete events."""
    user = getattr(instance, '_current_user', None)
    
    async_to_sync(broadcast_model_update)(
        '{{ model.name }}',
        instance.pk,
        'deleted',
        user
    )


{% endfor %}