"""
GraphQL queries for {{ app_name }} app.

Generated by Django Enhanced Generator on {{ now().strftime('%Y-%m-%d %H:%M:%S') }}.
"""
import graphene
from graphene_django.filter import DjangoFilterConnectionField
from django.db.models import Q
from graphql_jwt.decorators import login_required
{% if has_subscriptions %}from channels_graphql_ws import Subscription
{% endif %}

from ..models import {{ models|map(attribute='name')|join(', ') }}
from .types import {{ types|map(attribute='name')|join(', ') }}


class Query(graphene.ObjectType):
    """{{ app_name }} queries."""

    {% for model in models %}
    # Single {{ model.name }} query
    {{ model.name|lower }} = graphene.Field(
        {{ model.name }}Type,
        id=graphene.ID(required=True)
    )

# List {{ model.name|plural }} query
all_{{ model.name|lower|plural }} = DjangoFilterConnectionField(
    {{ model.name }}Type,
    description="List all {{ model.name|plural }}"
)

# Custom queries
{% if model.api and model.api.custom_queries %}
{% for query in model.api.custom_queries %}
{{ query.name }} = graphene.{{ query.return_type }}(
{% for arg in query.arguments %}
{{ arg.name }}=graphene.{{ arg.type }}({% if arg.required %}required=True{% endif %}),
{% endfor %}
description="{{ query.description }}"
)
{% endfor %}
{% endif %}

{% endfor %}

# Resolvers
{% for model in models %}
def resolve_{{ model.name|lower }}(self, info, id):
    """Resolve single {{ model.name }}."""
    try:
        instance = {{ model.name }}.objects.get(pk=id)

        # Check permissions
        if not info.context.user.has_perm('{{ app_name }}.view_{{ model.name|lower }}'):
            return None

        return instance
    except {{ model.name }}.DoesNotExist:
        return None

def resolve_all_{{ model.name|lower|plural }}(self, info, **kwargs):
    """Resolve all {{ model.name|plural }}."""
    # Check permissions
    if not info.context.user.has_perm('{{ app_name }}.view_{{ model.name|lower }}'):
        return {{ model.name }}.objects.none()

    queryset = {{ model.name }}.objects.all()

    {% if model.api and model.api.default_ordering %}
    # Apply default ordering
    queryset = queryset.order_by({{ model.api.default_ordering }})
    {% endif %}

    {% if model.api and model.api.select_related %}
    # Optimize queries
    queryset = queryset.select_related({{ model.api.select_related|join(', ') }})
    {% endif %}

    {% if model.api and model.api.prefetch_related %}
    queryset = queryset.prefetch_related({{ model.api.prefetch_related|join(', ') }})
    {% endif %}

    {% if model.features and model.features.soft_delete %}
    # Filter out soft deleted items
    queryset = queryset.filter(is_deleted=False)
    {% endif %}

    {% if features.enterprise.multitenancy %}
    # Filter by tenant
    if hasattr(info.context, 'tenant'):
        queryset = queryset.filter(tenant=info.context.tenant)
    {% endif %}

    return queryset

{% if model.api and model.api.custom_queries %}
# Custom query resolvers
{% for query in model.api.custom_queries %}
def resolve_{{ query.name }}(self, info, **kwargs):
    """{{ query.description }}"""
{{ query.implementation|indent(8) }}

{% endfor %}
{% endif %}
{% endfor %}


# Search queries
class SearchQuery(graphene.ObjectType):
    """Global search queries."""

    search = graphene.Field(
        graphene.List(graphene.JSONString),
        query=graphene.String(required=True),
        models=graphene.List(graphene.String),
        limit=graphene.Int(default_value=10)
    )

    def resolve_search(self, info, query, models=None, limit=10):
        """Global search across models."""
        results = []

        # Define searchable models
        searchable_models = {
            {% for model in models %}
            {% if model.api and model.api.searchable %}
            '{{ model.name|lower }}': {
                'model': {{ model.name }},
            'fields': {{ model.api.search_fields|default(['name'], true) }},
        'type': '{{ model.name }}'
        },
        {% endif %}
        {% endfor %}
        }

        # Filter models if specified
        if models:
            searchable_models = {
                k: v for k, v in searchable_models.items()
                if k in [m.lower() for m in models]
            }

        # Search each model
        for model_name, config in searchable_models.items():
            model_class = config['model']

            # Build Q objects for search
            q_objects = Q()
            for field in config['fields']:
                q_objects |= Q(**{f'{field}__icontains': query})

            # Get results
            queryset = model_class.objects.filter(q_objects)[:limit]

            # Format results
            for obj in queryset:
                results.append({
                    'type': config['type'],
                    'id': str(obj.pk),
                    'title': str(obj),
                    'data': {
                        field: getattr(obj, field, None)
                        for field in config['fields']
                    }
                })

        return results


# Statistics queries
class StatsQuery(graphene.ObjectType):
    """Statistics queries."""

    {% for model in models %}
    {% if model.api and model.api.enable_stats %}
    {{ model.name|lower }}_stats = graphene.Field(
        graphene.JSONString,
        date_from=graphene.Date(),
        date_to=graphene.Date()
    )

    def resolve_{{ model.name|lower }}_stats(self, info, date_from=None, date_to=None):
        """Get statistics for {{ model.name }}."""
        from django.db.models import Count, Avg, Sum, Min, Max
        from django.utils import timezone
        from datetime import timedelta

        queryset = {{ model.name }}.objects.all()

        # Apply date filters
        if date_from:
            queryset = queryset.filter(created_at__gte=date_from)
        if date_to:
            queryset = queryset.filter(created_at__lte=date_to)

        # Calculate statistics
        stats = {
            'total_count': queryset.count(),
            'date_range': {
                'from': date_from.isoformat() if date_from else None,
                'to': date_to.isoformat() if date_to else None,
            }
        }

        {% if model.api.stats_config %}
        # Custom statistics
        {% for stat in model.api.stats_config %}
        stats['{{ stat.name }}'] = queryset.aggregate(
            {{ stat.aggregation }}
        )
        {% endfor %}
        {% endif %}

        # Time series data
        if date_from and date_to:
            days = (date_to - date_from).days
            if days <= 31:
                # Daily stats
                stats['time_series'] = self._get_daily_stats(queryset, date_from, date_to)
            elif days <= 365:
                # Weekly stats
                stats['time_series'] = self._get_weekly_stats(queryset, date_from, date_to)
            else:
                # Monthly stats
                stats['time_series'] = self._get_monthly_stats(queryset, date_from, date_to)

        return stats

    def _get_daily_stats(self, queryset, date_from, date_to):
        """Get daily statistics."""
        from django.db.models import Count
        from django.db.models.functions import TruncDate

        return list(
            queryset
            .annotate(date=TruncDate('created_at'))
            .values('date')
            .annotate(count=Count('id'))
            .order_by('date')
        )

{% endif %}
{% endfor %}


# Combined query class
class {{ app_name|title }}Query(Query, SearchQuery, StatsQuery):
    """Combined queries for {{ app_name }}."""
    pass