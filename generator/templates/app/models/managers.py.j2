"""
Custom managers and querysets for {{ app_name }} app.

Generated by Django Enhanced Generator on {{ now().strftime('%Y-%m-%d %H:%M:%S') }}.
"""
from django.db import models
from django.db.models import Q, F, Count, Sum, Avg
from django.core.cache import cache
from django.utils import timezone
from datetime import timedelta
import logging

logger = logging.getLogger(__name__)


{% for queryset in querysets %}
class {{ queryset.class_name }}(models.QuerySet):
    """Custom queryset for {{ queryset.model_name }}."""
    
    {% for method in queryset.methods %}
    {{ method.implementation }}
    {% endfor %}
    
    def for_list_view(self):
        """Optimized queryset for list views."""
        {% if queryset.optimizations.only_fields %}
        return self.only({{ queryset.optimizations.only_fields|join(', ')|repr }})
        {% else %}
        return self
        {% endif %}
    
    def with_annotations(self):
        """Add useful annotations."""
        return self.annotate(
            days_since_created=timezone.now() - F('created_at'),
            {% if queryset.features.cache %}
            cache_key=models.Value(f"{{ queryset.model_name.lower() }}:", output_field=models.CharField())
            {% endif %}
        )
    
    {% if queryset.features.cache %}
    def cached(self, timeout=3600):
        """Return cached queryset results."""
        cache_key = f"{{ app_name }}:{{ queryset.model_name.lower() }}:queryset:{hash(str(self.query))}"
        
        result = cache.get(cache_key)
        if result is None:
            result = list(self)
            cache.set(cache_key, result, timeout)
            logger.debug(f"Cached queryset: {cache_key}")
        
        return result
    {% endif %}
    
    def delete(self):
        """Override delete to handle soft delete if enabled."""
        {% if queryset.features.soft_delete %}
        return self.update(
            deleted_at=timezone.now(),
            is_deleted=True
        )
        {% else %}
        return super().delete()
        {% endif %}


{% endfor %}

{% for manager in managers %}
class {{ manager.class_name }}(models.Manager):
    """Custom manager for {{ manager.model_name }}."""
    
    def get_queryset(self):
        """Return custom queryset."""
        return {{ manager.queryset_class }}(self.model, using=self._db)
    
    {% if manager.filters %}
    def get_queryset(self):
        """Return filtered queryset."""
        qs = super().get_queryset()
        {% for field, value in manager.filters.items() %}
        qs = qs.filter({{ field }}={{ value|repr }})
        {% endfor %}
        return qs
    {% endif %}
    
    {% for method in manager.methods %}
    {{ method.implementation }}
    {% endfor %}
    
    def bulk_create_optimized(self, objs, batch_size=1000, ignore_conflicts=False):
        """Optimized bulk create with batching."""
        created_objects = []
        
        for i in range(0, len(objs), batch_size):
            batch = objs[i:i + batch_size]
            created_batch = self.bulk_create(
                batch,
                ignore_conflicts=ignore_conflicts
            )
            created_objects.extend(created_batch)
            
            # Clear cache after each batch
            {% if manager.features.cache %}
            cache.delete_pattern(f"{{ app_name }}:{{ manager.model_name.lower() }}:*")
            {% endif %}
        
        return created_objects
    
    def get_or_create_optimized(self, defaults=None, **kwargs):
        """Optimized get_or_create with caching."""
        {% if manager.features.cache %}
        cache_key = f"{{ app_name }}:{{ manager.model_name.lower() }}:get_or_create:{hash(str(sorted(kwargs.items())))}"
        
        result = cache.get(cache_key)
        if result is not None:
            return result
        {% endif %}
        
        obj, created = self.get_or_create(defaults=defaults, **kwargs)
        
        {% if manager.features.cache %}
        cache.set(cache_key, (obj, created), 300)  # Cache for 5 minutes
        {% endif %}
        
        return obj, created


{% endfor %}

# Performance monitoring mixin
class PerformanceMonitoringMixin:
    """Mixin to monitor query performance."""
    
    def get_queryset(self):
        """Monitor queryset performance."""
        import time
        from django.conf import settings
        
        qs = super().get_queryset()
        
        if settings.DEBUG:
            class TimingQuerySet(qs.__class__):
                def __iter__(self):
                    start = time.time()
                    result = list(super().__iter__())
                    duration = time.time() - start
                    
                    if duration > 0.5:  # Log slow queries
                        logger.warning(
                            f"Slow query ({duration:.2f}s) in {{ app_name }}: {self.query}"
                        )
                    
                    return iter(result)
                
                def count(self):
                    start = time.time()
                    result = super().count()
                    duration = time.time() - start
                    
                    if duration > 0.1:  # Log slow counts
                        logger.warning(
                            f"Slow count query ({duration:.2f}s) in {{ app_name }}: {self.query}"
                        )
                    
                    return result
            
            qs.__class__ = TimingQuerySet
        
        return qs


# Cache invalidation helpers
{% if features.performance.caching %}
class CacheInvalidationMixin:
    """Mixin to handle cache invalidation."""
    
    def invalidate_cache(self, instance=None):
        """Invalidate related caches."""
        patterns = [
            f"{{ app_name }}:*",
        ]
        
        if instance:
            patterns.extend([
                f"{{ app_name }}:{instance.__class__.__name__.lower()}:{instance.pk}:*",
                f"{{ app_name }}:{instance.__class__.__name__.lower()}:list:*",
            ])
        
        for pattern in patterns:
            try:
                cache.delete_pattern(pattern)
            except Exception as e:
                logger.error(f"Cache invalidation failed for pattern {pattern}: {e}")
    
    def save(self, *args, **kwargs):
        """Override save to invalidate cache."""
        result = super().save(*args, **kwargs)
        self.invalidate_cache(self)
        return result
    
    def delete(self, *args, **kwargs):
        """Override delete to invalidate cache."""
        self.invalidate_cache(self)
        return super().delete(*args, **kwargs)
{% endif %}