"""
Business logic for {{ model_name }} model.

Generated by Django Enhanced Generator on {{ now().strftime('%Y-%m-%d %H:%M:%S') }}.
"""
from decimal import Decimal
from typing import Any, Optional, Dict, List
from django.core.exceptions import ValidationError
from django.contrib.contenttypes.models import ContentType
from django.utils import timezone
from django.db import transaction
from django.core.cache import cache
import logging

logger = logging.getLogger(__name__)


class {{ model_name }}BusinessLogic:
    """
    Business logic container for {{ model_name }} model.
    
    This class encapsulates all business rules, calculations,
    and domain-specific operations for {{ model_name }}.
    """
    
    def __init__(self, instance):
        self.instance = instance
    
    {% for method in methods %}
    {% for decorator in method.decorators %}
    {{ decorator }}
    {% endfor %}
    {{ method.implementation }}
    {% endfor %}
    
    {% for property in properties %}
    {% if property.cached %}
    @property
    def {{ property.name }}(self):
        """{{ property.description }} (cached)"""
        cache_key = f"{{ app_name }}:{{ model_name.lower() }}:{self.instance.pk}:{{ property.name }}"
        
        result = cache.get(cache_key)
        if result is None:
            result = self._calculate_{{ property.name }}()
            cache.set(cache_key, result, 3600)  # Cache for 1 hour
        
        return result
    
    def _calculate_{{ property.name }}(self):
        """Calculate {{ property.name }} value."""
        {{ property.implementation }}
    {% else %}
    @property
    def {{ property.name }}(self):
        """{{ property.description }}"""
        {{ property.implementation }}
    {% endif %}
    {% endfor %}
    
    def validate_business_rules(self) -> bool:
        """
        Validate all business rules for this instance.
        
        Returns:
            bool: True if all rules pass
            
        Raises:
            ValidationError: If any business rule fails
        """
        errors = []
        
        try:
            # Run all validation methods
            {% for method in methods %}
            {% if 'validate' in method.name %}
            self.{{ method.name }}()
            {% endif %}
            {% endfor %}
            
        except ValidationError as e:
            errors.extend(e.messages if hasattr(e, 'messages') else [str(e)])
        
        if errors:
            raise ValidationError(errors)
        
        return True
    
    def execute_business_action(self, action_name: str, **kwargs) -> Any:
        """
        Execute a business action by name.
        
        Args:
            action_name: Name of the action to execute
            **kwargs: Action parameters
            
        Returns:
            Any: Action result
        """
        if not hasattr(self, action_name):
            raise ValueError(f"Unknown business action: {action_name}")
        
        action_method = getattr(self, action_name)
        
        # Log business action
        logger.info(
            f"Executing business action '{action_name}' on "
            f"{{ model_name }} {self.instance.pk}"
        )
        
        try:
            with transaction.atomic():
                result = action_method(**kwargs)
                
                # Invalidate related caches
                self._invalidate_caches()
                
                return result
                
        except Exception as e:
            logger.error(
                f"Business action '{action_name}' failed on "
                f"{{ model_name }} {self.instance.pk}: {e}"
            )
            raise
    
    def _invalidate_caches(self):
        """Invalidate all caches related to this instance."""
        cache_patterns = [
            f"{{ app_name }}:{{ model_name.lower() }}:{self.instance.pk}:*",
            f"{{ app_name }}:{{ model_name.lower() }}:list:*",
        ]
        
        for pattern in cache_patterns:
            try:
                cache.delete_pattern(pattern)
            except Exception as e:
                logger.warning(f"Failed to invalidate cache pattern {pattern}: {e}")
    
    def get_business_metrics(self) -> Dict[str, Any]:
        """
        Get business metrics for this instance.
        
        Returns:
            Dict[str, Any]: Business metrics
        """
        metrics = {
            'instance_id': self.instance.pk,
            'model_name': '{{ model_name }}',
            'calculated_at': timezone.now().isoformat(),
        }
        
        # Add computed properties as metrics
        {% for property in properties %}
        try:
            metrics['{{ property.name }}'] = self.{{ property.name }}
        except Exception as e:
            logger.warning(f"Failed to calculate {{ property.name }}: {e}")
            metrics['{{ property.name }}'] = None
        {% endfor %}
        
        return metrics
    
    @classmethod
    def bulk_execute_action(cls, instances: List, action_name: str, **kwargs) -> List[Any]:
        """
        Execute a business action on multiple instances.
        
        Args:
            instances: List of model instances
            action_name: Name of the action to execute
            **kwargs: Action parameters
            
        Returns:
            List[Any]: List of action results
        """
        results = []
        
        with transaction.atomic():
            for instance in instances:
                business_logic = cls(instance)
                try:
                    result = business_logic.execute_business_action(action_name, **kwargs)
                    results.append(result)
                except Exception as e:
                    logger.error(f"Bulk action failed for instance {instance.pk}: {e}")
                    results.append(None)
        
        return results


# Business rule decorators
def business_rule(rule_name: str):
    """Decorator to mark methods as business rules."""
    def decorator(func):
        func._is_business_rule = True
        func._rule_name = rule_name
        return func
    return decorator


def cached_business_method(timeout: int = 3600):
    """Decorator to cache business method results."""
    def decorator(func):
        def wrapper(self, *args, **kwargs):
            # Create cache key from method name and arguments
            cache_key = f"{{ app_name }}:{{ model_name.lower() }}:{self.instance.pk}:{func.__name__}:{hash(str(args) + str(sorted(kwargs.items())))}"
            
            result = cache.get(cache_key)
            if result is None:
                result = func(self, *args, **kwargs)
                cache.set(cache_key, result, timeout)
            
            return result
        
        wrapper._is_cached = True
        wrapper._cache_timeout = timeout
        return wrapper
    
    return decorator


def audit_business_action(action_type: str = 'business_action'):
    """Decorator to audit business actions."""
    def decorator(func):
        def wrapper(self, *args, **kwargs):
            # Log action start
            logger.info(
                f"Starting {action_type} '{func.__name__}' on "
                f"{{ model_name }} {self.instance.pk}"
            )
            
            start_time = timezone.now()
            
            try:
                result = func(self, *args, **kwargs)
                
                # Log successful completion
                duration = (timezone.now() - start_time).total_seconds()
                logger.info(
                    f"Completed {action_type} '{func.__name__}' on "
                    f"{{ model_name }} {self.instance.pk} in {duration:.2f}s"
                )
                
                return result
                
            except Exception as e:
                # Log failure
                duration = (timezone.now() - start_time).total_seconds()
                logger.error(
                    f"Failed {action_type} '{func.__name__}' on "
                    f"{{ model_name }} {self.instance.pk} after {duration:.2f}s: {e}"
                )
                raise
        
        wrapper._is_audited = True
        wrapper._action_type = action_type
        return wrapper
    
    return decorator


# Status transition helpers
class StatusTransitionError(Exception):
    """Raised when a status transition is not allowed."""
    pass


def validate_status_transition(from_status: str, to_status: str, allowed_transitions: Dict[str, List[str]]) -> bool:
    """
    Validate if a status transition is allowed.
    
    Args:
        from_status: Current status
        to_status: Target status
        allowed_transitions: Dict mapping statuses to allowed next statuses
        
    Returns:
        bool: True if transition is allowed
        
    Raises:
        StatusTransitionError: If transition is not allowed
    """
    if from_status not in allowed_transitions:
        raise StatusTransitionError(f"Unknown status: {from_status}")
    
    if to_status not in allowed_transitions[from_status]:
        raise StatusTransitionError(
            f"Cannot transition from {from_status} to {to_status}. "
            f"Allowed transitions: {allowed_transitions[from_status]}"
        )
    
    return True