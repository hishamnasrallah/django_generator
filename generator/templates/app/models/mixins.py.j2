"""
Model mixins for {{ app_name }} app.

Generated by Django Enhanced Generator on {{ now().strftime('%Y-%m-%d %H:%M:%S') }}.
"""
from django.db import models
from django.utils.translation import gettext_lazy as _
from django.core.exceptions import ValidationError
from django.utils import timezone
from django.contrib.contenttypes.fields import GenericForeignKey
from django.contrib.contenttypes.models import ContentType
import hashlib
import json


class ValidatedModelMixin:
    """Mixin for models that need custom validation."""

    def clean(self):
        """Perform model validation."""
        super().clean()
        self.validate_unique_constraints()
        self.validate_business_rules()

    def validate_unique_constraints(self):
        """Validate custom unique constraints."""
        # Override in subclasses
        pass

    def validate_business_rules(self):
        """Validate business rules."""
        # Override in subclasses
        pass

    def save(self, *args, **kwargs):
        """Save with validation."""
        self.full_clean()
        super().save(*args, **kwargs)


class CachedModelMixin:
    """Mixin for models with caching support."""

    cache_timeout = 3600  # 1 hour default
    cache_prefix = None

    def get_cache_key(self, suffix=''):
        """Generate cache key for this instance."""
        prefix = self.cache_prefix or self.__class__.__name__.lower()
        key_parts = [prefix, str(self.pk)]
        if suffix:
            key_parts.append(suffix)
        return ':'.join(key_parts)

    def invalidate_cache(self):
        """Invalidate all caches for this instance."""
        from django.core.cache import cache
        # Invalidate common cache patterns
        cache.delete(self.get_cache_key())
        cache.delete(self.get_cache_key('detail'))
        cache.delete(self.get_cache_key('list'))

    def save(self, *args, **kwargs):
        """Save and invalidate cache."""
        super().save(*args, **kwargs)
        self.invalidate_cache()

    def delete(self, *args, **kwargs):
        """Delete and invalidate cache."""
        self.invalidate_cache()
        super().delete(*args, **kwargs)


class MetadataModelMixin(models.Model):
    """Mixin for models with JSON metadata field."""

    metadata = models.JSONField(
        _('metadata'),
        default=dict,
        blank=True,
        help_text=_('Additional metadata in JSON format')
    )

    class Meta:
        abstract = True

    def get_metadata(self, key, default=None):
        """Get metadata value by key."""
        return self.metadata.get(key, default)

    def set_metadata(self, key, value):
        """Set metadata value."""
        if self.metadata is None:
            self.metadata = {}
        self.metadata[key] = value

    def update_metadata(self, data):
        """Update metadata with dictionary."""
        if self.metadata is None:
            self.metadata = {}
        self.metadata.update(data)

    def clear_metadata(self):
        """Clear all metadata."""
        self.metadata = {}


class TaggedModelMixin(models.Model):
    """Mixin for models with tags."""

    tags = models.JSONField(
        _('tags'),
        default=list,
        blank=True,
        help_text=_('List of tags')
    )

    class Meta:
        abstract = True

    def add_tag(self, tag):
        """Add a tag."""
        if tag not in self.tags:
            self.tags.append(tag)

    def remove_tag(self, tag):
        """Remove a tag."""
        if tag in self.tags:
            self.tags.remove(tag)

    def has_tag(self, tag):
        """Check if has tag."""
        return tag in self.tags

    def clear_tags(self):
        """Clear all tags."""
        self.tags = []

    @classmethod
    def get_all_tags(cls):
        """Get all unique tags used."""
        tags = set()
        for obj in cls.objects.exclude(tags=[]):
            tags.update(obj.tags)
        return sorted(tags)


class VersionedModelMixin(models.Model):
    """Mixin for versioned models."""

    version = models.PositiveIntegerField(
        _('version'),
        default=1,
        help_text=_('Version number')
    )
    version_hash = models.CharField(
        _('version hash'),
        max_length=64,
        blank=True,
        help_text=_('Hash of versioned fields')
    )

    class Meta:
        abstract = True

    def get_versioned_fields(self):
        """Get list of fields to include in versioning."""
        # Override in subclasses
        exclude = ['id', 'version', 'version_hash', 'created_at', 'updated_at']
        return [f.name for f in self._meta.fields if f.name not in exclude]

    def calculate_version_hash(self):
        """Calculate hash of versioned fields."""
        data = {}
        for field in self.get_versioned_fields():
            value = getattr(self, field)
            if value is not None:
                data[field] = str(value)

        json_data = json.dumps(data, sort_keys=True)
        return hashlib.sha256(json_data.encode()).hexdigest()

    def save(self, *args, **kwargs):
        """Save with version tracking."""
        new_hash = self.calculate_version_hash()

        if self.pk and self.version_hash and new_hash != self.version_hash:
            # Content changed, increment version
            self.version += 1

        self.version_hash = new_hash
        super().save(*args, **kwargs)


class CommentableModelMixin(models.Model):
    """Mixin for models that can have comments."""

    comments_enabled = models.BooleanField(
        _('comments enabled'),
        default=True,
        help_text=_('Whether comments are enabled')
    )
    comments_count = models.PositiveIntegerField(
        _('comments count'),
        default=0,
        help_text=_('Number of comments')
    )

    class Meta:
        abstract = True

    def update_comments_count(self):
        """Update comments count."""
        # Assuming a Comment model with generic foreign key
        from django.contrib.contenttypes.models import ContentType
        ct = ContentType.objects.get_for_model(self)
        self.comments_count = Comment.objects.filter(
            content_type=ct,
            object_id=self.pk
        ).count()
        self.save(update_fields=['comments_count'])


class RatableModelMixin(models.Model):
    """Mixin for models that can be rated."""

    rating_sum = models.PositiveIntegerField(
        _('rating sum'),
        default=0,
        help_text=_('Sum of all ratings')
    )
    rating_count = models.PositiveIntegerField(
        _('rating count'),
        default=0,
        help_text=_('Number of ratings')
    )
    rating_average = models.DecimalField(
        _('rating average'),
        max_digits=3,
        decimal_places=2,
        default=0,
        help_text=_('Average rating')
    )

    class Meta:
        abstract = True

    def add_rating(self, rating):
        """Add a rating."""
        self.rating_sum += rating
        self.rating_count += 1
        self.rating_average = self.rating_sum / self.rating_count
        self.save(update_fields=['rating_sum', 'rating_count', 'rating_average'])

    def update_rating(self, old_rating, new_rating):
        """Update an existing rating."""
        self.rating_sum = self.rating_sum - old_rating + new_rating
        self.rating_average = self.rating_sum / self.rating_count
        self.save(update_fields=['rating_sum', 'rating_average'])


class SEOModelMixin(models.Model):
    """Mixin for SEO fields."""

    meta_title = models.CharField(
        _('meta title'),
        max_length=70,
        blank=True,
        help_text=_('SEO meta title')
    )
    meta_description = models.TextField(
        _('meta description'),
        max_length=160,
        blank=True,
        help_text=_('SEO meta description')
    )
    meta_keywords = models.CharField(
        _('meta keywords'),
        max_length=255,
        blank=True,
        help_text=_('SEO meta keywords')
    )
    canonical_url = models.URLField(
        _('canonical URL'),
        blank=True,
        help_text=_('Canonical URL for SEO')
    )

    class Meta:
        abstract = True

    def get_meta_title(self):
        """Get meta title or default."""
        return self.meta_title or str(self)

    def get_meta_description(self):
        """Get meta description or default."""
        if self.meta_description:
            return self.meta_description

        # Try to get from description or content field
        for field in ['description', 'content', 'summary']:
            if hasattr(self, field):
                value = getattr(self, field)
                if value:
                    return value[:160]

        return ''


class WorkflowModelMixin:
    """Mixin for models with workflow states."""

    def can_transition_to(self, new_state):
        """Check if transition to new state is allowed."""
        # Override in subclasses
        return True

    def transition_to(self, new_state, user=None):
        """Transition to new state."""
        if not self.can_transition_to(new_state):
            raise ValidationError(
                f"Cannot transition from {self.status} to {new_state}"
            )

        old_state = self.status
        self.status = new_state
        self.save()

        # Log transition
        self.log_transition(old_state, new_state, user)

    def log_transition(self, old_state, new_state, user=None):
        """Log state transition."""
        # Override to implement logging
        pass


class SchedulableModelMixin(models.Model):
    """Mixin for schedulable models."""

    scheduled_for = models.DateTimeField(
        _('scheduled for'),
        null=True,
        blank=True,
        db_index=True,
        help_text=_('Date and time to activate')
    )
    expires_at = models.DateTimeField(
        _('expires at'),
        null=True,
        blank=True,
        db_index=True,
        help_text=_('Date and time to expire')
    )

    class Meta:
        abstract = True

    @property
    def is_scheduled(self):
        """Check if item is scheduled for future."""
        return (
                self.scheduled_for and
                self.scheduled_for > timezone.now()
        )

    @property
    def is_expired(self):
        """Check if item is expired."""
        return (
                self.expires_at and
                self.expires_at < timezone.now()
        )

    @property
    def is_active(self):
        """Check if item is currently active."""
        now = timezone.now()

        if self.scheduled_for and now < self.scheduled_for:
            return False

        if self.expires_at and now > self.expires_at:
            return False

        return True