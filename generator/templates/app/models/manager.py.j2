"""
Custom manager for {{ model_name }} model.

Generated by Django Enhanced Generator on {{ now().strftime('%Y-%m-%d %H:%M:%S') }}.
"""
from django.db import models
from django.db.models import Q, Count, Sum, Avg, F
from django.utils import timezone
from datetime import timedelta


class {{ model_name }}QuerySet(models.QuerySet):
    """Custom queryset for {{ model_name }}."""

    {% if has_soft_delete %}
    def active(self):
        """Return only non-deleted items."""
        return self.filter(is_deleted=False)

    def deleted(self):
        """Return only soft-deleted items."""
        return self.filter(is_deleted=True)
    {% endif %}

    {% if has_status_field %}
    def by_status(self, status):
        """Filter by status."""
        return self.filter(status=status)

    def published(self):
        """Return only published items."""
        return self.filter(status='published')

    def draft(self):
        """Return only draft items."""
        return self.filter(status='draft')
    {% endif %}

    {% if has_date_fields %}
    def recent(self, days=7):
        """Return items from the last N days."""
        cutoff = timezone.now() - timedelta(days=days)
        return self.filter(created_at__gte=cutoff)

    def date_range(self, start_date, end_date):
        """Filter by date range."""
        return self.filter(
            created_at__date__gte=start_date,
            created_at__date__lte=end_date
        )
    {% endif %}

    {% if has_user_fields %}
    def by_user(self, user):
        """Filter by user."""
        return self.filter(
            Q(created_by=user) | Q(updated_by=user)
        )

    def owned_by(self, user):
        """Filter by owner."""
        return self.filter(created_by=user)
    {% endif %}

    def search(self, query):
        """Search in searchable fields."""
        if not query:
            return self

        q_objects = Q()
        search_fields = {{ search_fields|default(['name', 'title', 'description']) }}

        for field in search_fields:
            q_objects |= Q(**{f'{field}__icontains': query})

        return self.filter(q_objects)

    def with_counts(self):
        """Add related counts."""
        return self.annotate(
            {% for relation in relations %}
            {{ relation.name }}_count=Count('{{ relation.field }}'),
            {% endfor %}
        )

    def optimized(self):
        """Return optimized queryset with select/prefetch related."""
        qs = self
        {% if select_related %}
        qs = qs.select_related({{ select_related|join(', ')|repr }})
        {% endif %}
        {% if prefetch_related %}
        qs = qs.prefetch_related({{ prefetch_related|join(', ')|repr }})
        {% endif %}
        return qs

    {% for method in custom_methods %}
    def {{ method.name }}(self{{ ', ' + method.params|join(', ') if method.params }}):
        """{{ method.description }}"""
{{ method.implementation|indent(8) }}

{% endfor %}


class {{ model_name }}Manager(models.Manager):
    """Custom manager for {{ model_name }}."""

    def get_queryset(self):
        """Return custom queryset."""
        return {{ model_name }}QuerySet(self.model, using=self._db)

    {% if has_soft_delete %}
    def active(self):
        """Return only non-deleted items."""
        return self.get_queryset().active()

    def deleted(self):
        """Return only soft-deleted items."""
        return self.get_queryset().deleted()

    def with_deleted(self):
        """Return all items including deleted."""
        return self.get_queryset()
    {% endif %}

    {% if has_status_field %}
    def published(self):
        """Return only published items."""
        return self.get_queryset().published()

    def draft(self):
        """Return only draft items."""
        return self.get_queryset().draft()
    {% endif %}

    def create_with_defaults(self, **kwargs):
        """Create with default values."""
        defaults = {
            {% for field, value in default_values.items() %}
            '{{ field }}': {{ value }},
        {% endfor %}
        }
        defaults.update(kwargs)
        return self.create(**defaults)

    def get_or_none(self, **kwargs):
        """Get object or return None."""
        try:
            return self.get(**kwargs)
        except self.model.DoesNotExist:
            return None

    def bulk_create_optimized(self, objs, batch_size=1000):
        """Optimized bulk create with batching."""
        created = []
        for i in range(0, len(objs), batch_size):
            batch = objs[i:i + batch_size]
            created.extend(self.bulk_create(batch))
        return created

    {% for method in manager_methods %}
    def {{ method.name }}(self{{ ', ' + method.params|join(', ') if method.params }}):
        """{{ method.description }}"""
{{ method.implementation|indent(8) }}

{% endfor %}


{% if additional_managers %}
# Additional managers
{% for manager in additional_managers %}
class {{ manager.name }}({{ model_name }}Manager):
    """{{ manager.description }}"""

    def get_queryset(self):
        """Return filtered queryset."""
        return super().get_queryset(){{ manager.filter }}

    {% for method in manager.methods %}
    def {{ method.name }}(self{{ ', ' + method.params|join(', ') if method.params }}):
        """{{ method.description }}"""
{{ method.implementation|indent(8) }}

{% endfor %}


{% endfor %}
{% endif %}