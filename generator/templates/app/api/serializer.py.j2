"""
Serializers for {{ app_name }} app.

Generated by Django Enhanced Generator on {{ now().strftime('%Y-%m-%d %H:%M:%S') }}.
"""
{% for import_type, import_list in imports.items() %}{% if import_list %}
# {{ import_type|title }} imports
{% for import_line in import_list %}{{ import_line }}
{% endfor %}{% endif %}{% endfor %}

{% if has_nested %}
# Forward declarations for circular imports
{% for model in models %}{{ model.name }}Serializer = None
{% endfor %}
{% endif %}


class BaseSerializer(serializers.ModelSerializer):
    """Base serializer with common functionality."""

    def __init__(self, *args, **kwargs):
        # Don't pass the 'fields' arg up to the superclass
        fields = kwargs.pop('fields', None)
        # Don't pass the 'exclude' arg up to the superclass
        exclude = kwargs.pop('exclude', None)

        # Instantiate the superclass normally
        super().__init__(*args, **kwargs)

        if fields is not None:
            # Drop any fields that are not specified in the `fields` argument.
            allowed = set(fields)
            existing = set(self.fields)
            for field_name in existing - allowed:
                self.fields.pop(field_name)

        if exclude is not None:
            # Remove fields specified in the `exclude` argument.
            for field_name in exclude:
                self.fields.pop(field_name, None)


{% for model in models %}
class {{ model.name }}Serializer(BaseSerializer):
    """
    Serializer for {{ model.name }} model.
    {% if model.api and model.api.description %}

    {{ model.api.description }}
    {% endif %}
    """
    {% if model.api and model.api.read_only_fields %}
    # Read-only fields
    {% for field in model.api.read_only_fields %}
    {{ field }} = serializers.ReadOnlyField()
    {% endfor %}{% endif %}

    {% if model.api and model.api.write_only_fields %}
    # Write-only fields
    {% for field in model.api.write_only_fields %}
    {{ field }} = serializers.CharField(write_only=True{% if field.endswith('password') %}, style={'input_type': 'password'}{% endif %})
{% endfor %}{% endif %}

{% if relationships.forward[model.name] %}
# Related fields
{% for rel in relationships.forward[model.name] %}{% if rel.type == 'ForeignKey' %}
{{ rel.field }}_id = serializers.PrimaryKeyRelatedField(
    queryset={{ rel.to_model.split('.')[-1] }}.objects.all(),
source='{{ rel.field }}',
write_only=True
)
{{ rel.field }}_detail = serializers.SerializerMethodField(read_only=True)
{% elif rel.type == 'ManyToManyField' %}
{{ rel.field }}_ids = serializers.PrimaryKeyRelatedField(
    many=True,
    queryset={{ rel.to_model.split('.')[-1] }}.objects.all(),
source='{{ rel.field }}',
write_only=True
)
{{ rel.field }}_detail = serializers.SerializerMethodField(read_only=True)
{% endif %}{% endfor %}{% endif %}

{% if model.api and model.api.computed_fields %}
# Computed fields
{% for field in model.api.computed_fields %}
{{ field.name }} = serializers.SerializerMethodField()
{% endfor %}{% endif %}

class Meta:
    model = {{ model.name }}
    fields = '__all__'
    {% if model.api and model.api.read_only_fields %}
    read_only_fields = {{ model.api.read_only_fields }}
    {% endif %}
    {% if model.api and model.api.extra_kwargs %}
    extra_kwargs = {{ model.api.extra_kwargs }}
    {% endif %}

    {% if relationships.forward[model.name] %}
    # Methods for related fields
{% for rel in relationships.forward[model.name] %}
def get_{{ rel.field }}_detail(self, obj):
    """Get detailed information for {{ rel.field }}."""
    if obj.{{ rel.field }}:
    {% if rel.type == 'ManyToManyField' %}
        return {{ rel.to_model.split('.')[-1] }}Serializer(obj.{{ rel.field }}.all(), many=True, context=self.context).data
        {% else %}
        return {{ rel.to_model.split('.')[-1] }}Serializer(obj.{{ rel.field }}, context=self.context).data
    {% endif %}
    return None
{% endfor %}{% endif %}

{% if model.api and model.api.computed_fields %}
# Methods for computed fields
{% for field in model.api.computed_fields %}
def get_{{ field.name }}(self, obj):
    """{{ field.description|default('Compute ' + field.name, true) }}"""
    {% if field.method %}
    return obj.{{ field.method }}()
    {% else %}
    # Implement computation logic here
    return None
{% endif %}
{% endfor %}{% endif %}

{% if model.api and model.api.validation_methods %}
# Validation methods
{% for validation in model.api.validation_methods %}
def validate_{{ validation.field }}(self, value):
    """{{ validation.description|default('Validate ' + validation.field, true) }}"""
    {{ validation.implementation|indent(8) }}
    return value
{% endfor %}{% endif %}

def validate(self, attrs):
    """Object-level validation."""
    {% if model.api and model.api.object_validation %}
    {{ model.api.object_validation|indent(8) }}
    {% endif %}
    return super().validate(attrs)

{% if model.features and model.features.audit %}
def create(self, validated_data):
    """Create with audit trail."""
    validated_data['created_by'] = self.context['request'].user
    return super().create(validated_data)

def update(self, instance, validated_data):
    """Update with audit trail."""
    validated_data['updated_by'] = self.context['request'].user
    return super().update(instance, validated_data)
{% endif %}

{% if model.api and model.api.nested_creates %}
@transaction.atomic
def create(self, validated_data):
    """Create with nested objects."""
    # Extract nested data
    {% for nested in model.api.nested_creates %}
    {{ nested.field }}_data = validated_data.pop('{{ nested.field }}', [])
    {% endfor %}

    # Create main object
    instance = super().create(validated_data)

    # Create nested objects
    {% for nested in model.api.nested_creates %}
    for item_data in {{ nested.field }}_data:
        {{ nested.model }}.objects.create({{ nested.parent_field }}=instance, **item_data)
        {% endfor %}

        return instance
{% endif %}


{% if model.api and model.api.list_serializer %}
class {{ model.name }}ListSerializer(BaseSerializer):
    """Lightweight serializer for {{ model.name }} lists."""
    {% if relationships.forward[model.name] %}
    # Include only essential related data
    {% for rel in relationships.forward[model.name] %}{% if rel.type == 'ForeignKey' %}
    {{ rel.field }}_name = serializers.CharField(source='{{ rel.field }}.name', read_only=True)
    {% endif %}{% endfor %}{% endif %}

    class Meta:
        model = {{ model.name }}
        fields = [
            'id',
            {% for field in model.fields %}{% if field.name in ['name', 'title', 'status', 'created_at'] %}'{{ field.name }}',
            {% endif %}{% endfor %}{% if relationships.forward[model.name] %}{% for rel in relationships.forward[model.name] %}{% if rel.type == 'ForeignKey' %}'{{ rel.field }}_name',
            {% endif %}{% endfor %}{% endif %}
        ]
{% endif %}


{% if model.api and model.api.detail_serializer %}
class {{ model.name }}DetailSerializer({{ model.name }}Serializer):
    """Detailed serializer for {{ model.name }} with all relationships."""
    {% if relationships.reverse[model.name] %}
    # Reverse relationships
    {% for rel in relationships.reverse[model.name] %}
    {{ rel.related_name }} = {{ rel.from_model }}Serializer(many=True, read_only=True)
{% endfor %}{% endif %}

class Meta({{ model.name }}Serializer.Meta):
    fields = '__all__'
{% endif %}


{% if model.api and model.api.write_serializer %}
class {{ model.name }}WriteSerializer(BaseSerializer):
    """Serializer for creating/updating {{ model.name }}."""

    class Meta:
        model = {{ model.name }}
        fields = [
            {% for field in model.fields %}{% if not field.auto_now and not field.auto_now_add and field.name not in ['created_by', 'updated_by'] %}'{{ field.name }}',
            {% endif %}{% endfor %}
        ]

    def validate(self, attrs):
        """Perform write-specific validation."""
        {% if model.api.write_validation %}
        {{ model.api.write_validation|indent(8) }}
        {% endif %}
        return super().validate(attrs)
{% endif %}


{% endfor %}

{% if features.api.bulk_operations %}
# Bulk operation serializers
{% for model in models %}{% if model.api and model.api.allow_bulk %}
class {{ model.name }}BulkSerializer(serializers.Serializer):
    """Serializer for bulk operations on {{ model.name }}."""
    ids = serializers.ListField(
        child=serializers.IntegerField(),
        allow_empty=False
    )
    action = serializers.ChoiceField(choices=['delete', 'update'])
    data = serializers.DictField(required=False)

    def validate(self, attrs):
        if attrs['action'] == 'update' and not attrs.get('data'):
            raise serializers.ValidationError("Data is required for update action")
        return attrs
{% endif %}{% endfor %}
{% endif %}

{% if features.api.filters %}
# Filter serializers
{% for model in models %}{% if model.api and model.api.filterset_fields %}
class {{ model.name }}FilterSerializer(serializers.Serializer):
    """Serializer for {{ model.name }} filters."""
    {% for field in model.api.filterset_fields %}
    {{ field }} = serializers.CharField(required=False)
{{ field }}__icontains = serializers.CharField(required=False)
{% endfor %}
ordering = serializers.ChoiceField(
    choices=[{% for field in model.api.ordering_fields %}'{{ field }}', '-{{ field }}', {% endfor %}],
    required=False
)
{% endif %}{% endfor %}
{% endif %}