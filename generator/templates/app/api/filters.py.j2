"""
API filters for {{ app_name }} app.

Generated by Django Enhanced Generator on {{ now().strftime('%Y-%m-%d %H:%M:%S') }}.
"""
import django_filters
from django_filters import rest_framework as filters
from django.db.models import Q
from datetime import datetime, timedelta

from ..models import {{ models|map(attribute='name')|join(', ') }}


class BaseFilterSet(filters.FilterSet):
    """Base filter set with common functionality."""

    def __init__(self, data=None, *args, **kwargs):
        # Clean empty values from query params
        if data is not None:
            data = data.copy()
            for key in list(data.keys()):
                if not data.get(key):
                    del data[key]

        super().__init__(data, *args, **kwargs)


{% for model in models %}
{% if model.api and model.api.filterset_fields %}
class {{ model.name }}Filter(BaseFilterSet):
    """Filter for {{ model.name }} model."""

    {% for field in model.api.filterset_fields %}
    {% if field is string %}
    # Basic field filter
    {{ field }} = filters.CharFilter(lookup_expr='icontains')
    {% else %}
    # Advanced field filter
    {{ field.name }} = filters.{{ field.filter_class|default('CharFilter', true) }}(
                               {% if field.field_name %}field_name='{{ field.field_name }}',
                               {% endif %}{% if field.lookup_expr %}lookup_expr='{{ field.lookup_expr }}',
                               {% endif %}{% if field.method %}method='filter_{{ field.name }}',
                               {% endif %}{% if field.label %}label='{{ field.label }}',
                               {% endif %}
                               )
{% endif %}
{% endfor %}

# Date range filters
{% for field in model.fields %}
{% if field.type in ['DateField', 'DateTimeField'] %}
{{ field.name }}_after = filters.DateFilter(field_name='{{ field.name }}', lookup_expr='gte')
{{ field.name }}_before = filters.DateFilter(field_name='{{ field.name }}', lookup_expr='lte')
{% endif %}
{% endfor %}

# Ordering
ordering = filters.OrderingFilter(
    fields=(
        {% for field in model.api.ordering_fields %}
        ('{{ field }}', '{{ field }}'),
        {% endfor %}
    ),
    field_labels={
        {% for field in model.api.ordering_fields %}
        '{{ field }}': '{{ field|title_case }}',
        {% endfor %}
    }
)

# Custom filters
{% if model.api.custom_filters %}
{% for filter in model.api.custom_filters %}
{{ filter.name }} = filters.{{ filter.type|default('CharFilter', true) }}(method='filter_{{ filter.name }}')

def filter_{{ filter.name }}(self, queryset, name, value):
    """{{ filter.description|default('Custom filter: ' + filter.name, true) }}"""
{{ filter.implementation|indent(8) }}

{% endfor %}
{% endif %}

# Search filter
search = filters.CharFilter(method='filter_search')

def filter_search(self, queryset, name, value):
    """Search across multiple fields."""
    if not value:
        return queryset

    search_fields = {{ model.api.search_fields|default(['name'], true) }}

    q_objects = Q()
    for field in search_fields:
        q_objects |= Q(**{f'{field}__icontains': value})

    return queryset.filter(q_objects)

class Meta:
    model = {{ model.name }}
    fields = {
        {% for field in model.api.filterset_fields %}
        {% if field is string %}
        '{{ field }}': ['exact', 'icontains', 'in'],
        {% endif %}
        {% endfor %}
    }


{% endif %}
{% endfor %}

# Specialized filters

class DateRangeFilter(filters.FilterSet):
    """Mixin for date range filtering."""

    date_from = filters.DateFilter(field_name='created_at', lookup_expr='gte')
    date_to = filters.DateFilter(field_name='created_at', lookup_expr='lte')

    # Predefined ranges
    date_range = filters.ChoiceFilter(
        choices=[
            ('today', 'Today'),
            ('yesterday', 'Yesterday'),
            ('week', 'This Week'),
            ('month', 'This Month'),
            ('year', 'This Year'),
            ('last_week', 'Last Week'),
            ('last_month', 'Last Month'),
        ],
        method='filter_date_range'
    )

    def filter_date_range(self, queryset, name, value):
        """Filter by predefined date ranges."""
        today = datetime.now().date()

        if value == 'today':
            return queryset.filter(created_at__date=today)
        elif value == 'yesterday':
            return queryset.filter(created_at__date=today - timedelta(days=1))
        elif value == 'week':
            return queryset.filter(created_at__gte=today - timedelta(days=7))
        elif value == 'month':
            return queryset.filter(
                created_at__month=today.month,
                created_at__year=today.year
            )
        elif value == 'year':
            return queryset.filter(created_at__year=today.year)
        elif value == 'last_week':
            end = today - timedelta(days=7)
            start = end - timedelta(days=7)
            return queryset.filter(created_at__date__range=[start, end])
        elif value == 'last_month':
            if today.month == 1:
                month = 12
                year = today.year - 1
            else:
                month = today.month - 1
                year = today.year
            return queryset.filter(
                created_at__month=month,
                created_at__year=year
            )

        return queryset


class StatusFilter(filters.FilterSet):
    """Mixin for status filtering."""

    status = filters.MultipleChoiceFilter()
    exclude_status = filters.MultipleChoiceFilter(
        field_name='status',
        exclude=True
    )


class RelatedFilter(filters.FilterSet):
    """Mixin for filtering by related objects."""

    def filter_has_related(self, queryset, name, value):
        """Filter objects that have/don't have related objects."""
        field_name = name.replace('has_', '')

        if value:
            return queryset.exclude(**{f'{field_name}__isnull': True})
        else:
            return queryset.filter(**{f'{field_name}__isnull': True})


# Compound filters for complex queries
{% for model in models %}
{% if model.api and model.api.compound_filters %}
class {{ model.name }}CompoundFilter({{ model.name }}Filter):
    """Advanced compound filters for {{ model.name }}."""

    {% for filter in model.api.compound_filters %}
    {{ filter.name }} = filters.BooleanFilter(method='filter_{{ filter.name }}')

def filter_{{ filter.name }}(self, queryset, name, value):
    """{{ filter.description }}"""
    if value is None:
        return queryset

{{ filter.implementation|indent(8) }}

{% endfor %}
{% endif %}
{% endfor %}