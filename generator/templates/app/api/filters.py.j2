"""
API filters for {{ app_name }} app.

Generated by Django Enhanced Generator on {{ now().strftime('%Y-%m-%d %H:%M:%S') }}.
"""
import django_filters
from django_filters import rest_framework as filters
from django.db.models import Q

{% if models %}
from .models import {{ models|selectattr('name')|map(attribute='name')|join(', ') }}
{% endif %}


{% for model in models if model and model.get('name') %}
{% set model_name = model.get('name', 'Model') %}
{% set model_api = model.get('api', {}) if model else {} %}
{% set filterset_fields = model_api.get('filterset_fields', []) %}

class {{ model_name }}Filter(filters.FilterSet):
    """
    Filter class for {{ model_name }} model.
    """
    {% if filterset_fields %}
    # Custom filters
    {% for field in filterset_fields %}
    {% if field and isinstance(field, dict) %}
    {{ field.get('name', 'field') }} = filters.{{ field.get('type', 'CharFilter') }}(
                                               field_name='{{ field.get('field_name', field.get('name', 'field')) }}',
                                               {% if field.get('lookup_expr') %}
                                               lookup_expr='{{ field.get('lookup_expr') }}',
                                               {% endif %}
                                               {% if field.get('label') %}
                                               label='{{ field.get('label') }}',
                                               {% endif %}
                                               )
{% endif %}
{% endfor %}
{% endif %}

# Date range filters
{% for field in model.get('fields', []) %}
{% if field and field.get('type') in ['DateField', 'DateTimeField'] %}
{{ field.get('name', 'date') }}_after = filters.DateFilter(
    field_name='{{ field.get('name', 'date') }}',
    lookup_expr='gte',
    label='{{ field.get('name', 'date')|title }} after'
)
{{ field.get('name', 'date') }}_before = filters.DateFilter(
    field_name='{{ field.get('name', 'date') }}',
    lookup_expr='lte',
    label='{{ field.get('name', 'date')|title }} before'
)
{% endif %}
{% endfor %}

# Search filter
search = filters.CharFilter(method='filter_search', label='Search')

class Meta:
    model = {{ model_name }}
    fields = {
        {% for field in model.get('fields', []) %}
        {% if field and field.get('name') and field.get('type') in ['CharField', 'TextField'] %}
        '{{ field.get('name') }}': ['exact', 'icontains', 'istartswith'],
        {% elif field and field.get('name') and field.get('type') in ['IntegerField', 'DecimalField', 'FloatField'] %}
        '{{ field.get('name') }}': ['exact', 'lt', 'lte', 'gt', 'gte'],
        {% elif field and field.get('name') and field.get('type') == 'BooleanField' %}
        '{{ field.get('name') }}': ['exact'],
        {% elif field and field.get('name') and field.get('type') in ['ForeignKey', 'OneToOneField'] %}
        '{{ field.get('name') }}': ['exact'],
        '{{ field.get('name') }}__id': ['exact', 'in'],
        {% endif %}
        {% endfor %}
    }

def filter_search(self, queryset, name, value):
    """
    Custom search implementation.
    """
    if not value:
        return queryset

    # Define searchable fields
    search_fields = [
        {% for field in model.get('fields', []) %}
        {% if field and field.get('name') and field.get('type') in ['CharField', 'TextField'] %}
        '{{ field.get('name') }}',
        {% endif %}
        {% endfor %}
    ]

    # Build Q objects for search
    q_objects = Q()
    for field in search_fields:
        q_objects |= Q(**{f'{field}__icontains': value})

    return queryset.filter(q_objects)

{% if model_api.get('custom_filters') %}
# Custom filter methods
{% for custom_filter in model_api.get('custom_filters', []) %}
def filter_{{ custom_filter.get('name', 'custom') }}(self, queryset, name, value):
    """
{{ custom_filter.get('description', 'Custom filter') }}
        """
{{ custom_filter.get('implementation', 'return queryset')|indent(8) }}
{% endfor %}
{% endif %}


{% endfor %}

# Utility filter mixins
class OrderingFilterMixin:
    """
    Mixin to add consistent ordering options.
    """
    ordering = filters.OrderingFilter(
        fields=(
            ('created_at', 'created_at'),
            ('updated_at', 'updated_at'),
            ('id', 'id'),
        ),
        field_labels={
            'created_at': 'Creation date',
            'updated_at': 'Last update',
            'id': 'ID',
        }
    )


class DateRangeFilterMixin:
    """
    Mixin to add date range filtering.
    """
    date_from = filters.DateFilter(
        field_name='created_at',
        lookup_expr='gte',
        label='Created after'
    )
    date_to = filters.DateFilter(
        field_name='created_at',
        lookup_expr='lte',
        label='Created before'
    )


class ActiveFilterMixin:
    """
    Mixin to filter by active/inactive status.
    """
    is_active = filters.BooleanFilter(
        field_name='is_active',
        label='Active only'
    )
    include_inactive = filters.BooleanFilter(
        method='filter_include_inactive',
        label='Include inactive'
    )

    def filter_include_inactive(self, queryset, name, value):
        """
        Include inactive items if value is True.
        """
        if value:
            return queryset
        return queryset.filter(is_active=True)