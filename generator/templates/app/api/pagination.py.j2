"""
API pagination classes for {{ app_name }} app.

Generated by Django Enhanced Generator on {{ now().strftime('%Y-%m-%d %H:%M:%S') }}.
"""
from rest_framework import pagination
from rest_framework.response import Response
from collections import OrderedDict


class StandardResultsSetPagination(pagination.PageNumberPagination):
    """
    Standard pagination with customizable page size.
    """
    page_size = 20
    page_size_query_param = 'page_size'
    max_page_size = 100

    def get_paginated_response(self, data):
        return Response(OrderedDict([
            ('count', self.page.paginator.count),
            ('next', self.get_next_link()),
            ('previous', self.get_previous_link()),
            ('page_size', self.page_size),
            ('total_pages', self.page.paginator.num_pages),
            ('current_page', self.page.number),
            ('results', data)
        ]))


class LargeResultsSetPagination(pagination.PageNumberPagination):
    """
    Pagination for large result sets.
    """
    page_size = 50
    page_size_query_param = 'page_size'
    max_page_size = 200


class SmallResultsSetPagination(pagination.PageNumberPagination):
    """
    Pagination for small result sets.
    """
    page_size = 10
    page_size_query_param = 'page_size'
    max_page_size = 50


class CursorPagination(pagination.CursorPagination):
    """
    Cursor-based pagination for real-time data.
    """
    page_size = 20
    page_size_query_param = 'page_size'
    max_page_size = 100
    ordering = '-created_at'
    cursor_query_param = 'cursor'
    cursor_query_description = 'The pagination cursor value.'

    def get_paginated_response(self, data):
        return Response(OrderedDict([
            ('next', self.get_next_link()),
            ('previous', self.get_previous_link()),
            ('results', data)
        ]))


class LimitOffsetPagination(pagination.LimitOffsetPagination):
    """
    Limit/offset pagination.
    """
    default_limit = 20
    limit_query_param = 'limit'
    offset_query_param = 'offset'
    max_limit = 100

    def get_paginated_response(self, data):
        return Response(OrderedDict([
            ('count', self.count),
            ('next', self.get_next_link()),
            ('previous', self.get_previous_link()),
            ('limit', self.limit),
            ('offset', self.offset),
            ('results', data)
        ]))


{% set features_dict = features if features else {} %}
{% if features_dict.get('api', {}).get('custom_pagination') %}
# Custom pagination classes
{% for custom_pag in features_dict.get('api', {}).get('custom_pagination', []) %}
class {{ custom_pag.get('name', 'CustomPagination') }}(pagination.{{ custom_pag.get('base_class', 'PageNumberPagination') }}):
    """
    {{ custom_pag.get('description', 'Custom pagination class') }}
    """
    page_size = {{ custom_pag.get('page_size', 20) }}
    page_size_query_param = '{{ custom_pag.get('page_size_param', 'page_size') }}'
    max_page_size = {{ custom_pag.get('max_page_size', 100) }}

    {% if custom_pag.get('custom_response') %}
    def get_paginated_response(self, data):
        """
        Custom paginated response format.
        """
{{ custom_pag.get('custom_response')|indent(8) }}
{% endif %}


{% endfor %}
{% endif %}

class DynamicPageSizePagination(pagination.PageNumberPagination):
    """
    Pagination with dynamic page size based on client preference.
    """
    page_size_query_param = 'page_size'
    max_page_size = 500

    def get_page_size(self, request):
        """
        Determine page size based on request.
        """
        if self.page_size_query_param:
            try:
                page_size = int(request.query_params[self.page_size_query_param])
                if page_size > 0:
                    if self.max_page_size:
                        return min(page_size, self.max_page_size)
                    return page_size
            except (KeyError, ValueError):
                pass

        # Default page sizes based on client type
        user_agent = request.META.get('HTTP_USER_AGENT', '').lower()

        if 'mobile' in user_agent:
            return 10  # Smaller page size for mobile
        elif 'tablet' in user_agent:
            return 20  # Medium page size for tablets
        else:
            return 50  # Larger page size for desktop

    def get_paginated_response(self, data):
        return Response(OrderedDict([
            ('count', self.page.paginator.count),
            ('next', self.get_next_link()),
            ('previous', self.get_previous_link()),
            ('page_size', self.get_page_size(self.request)),
            ('total_pages', self.page.paginator.num_pages),
            ('current_page', self.page.number),
            ('results', data),
            ('meta', {
                'has_next': self.page.has_next(),
                'has_previous': self.page.has_previous(),
                'page_range': list(self.page.paginator.page_range),
            })
        ]))


class NoPagination(pagination.BasePagination):
    """
    No pagination - returns all results.
    Use with caution, only for small datasets.
    """

    def paginate_queryset(self, queryset, request, view=None):
        return None

    def get_paginated_response(self, data):
        return Response(data)