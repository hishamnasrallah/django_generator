"""
Model tests for {{ app_name }} app.

Generated by Django Enhanced Generator on {{ now().strftime('%Y-%m-%d %H:%M:%S') }}.
"""
import pytest
from django.core.exceptions import ValidationError
from django.db import IntegrityError
from django.utils import timezone
from datetime import timedelta

from ..models import {{ models|map(attribute='name')|join(', ') }}


{% for model in models %}
@pytest.mark.django_db
class Test{{ model.name }}Model:
    """Test {{ model.name }} model."""

    def test_create_{{ model.name|lower }}(self, {{ model.name|lower }}_dict):
        """Test creating a {{ model.name }} instance."""
        instance = {{ model.name }}.objects.create(**{{ model.name|lower }}_dict)

        assert instance.pk is not None
        assert isinstance(instance, {{ model.name }})
        {% for field in model.fields[:3] %}
        {% if field.name in model.name|lower + '_dict' %}
        assert instance.{{ field.name }} == {{ model.name|lower }}_dict['{{ field.name }}']
    {% endif %}
    {% endfor %}

    def test_str_representation(self, {{ model.name|lower }}):
        """Test string representation of {{ model.name }}."""
        str_repr = str({{ model.name|lower }})
        assert str_repr is not None
        assert len(str_repr) > 0
        {% if model.str_field %}
        assert str({{ model.name|lower }}.{{ model.str_field }}) in str_repr
    {% endif %}

    {% if model.unique_fields %}
    def test_unique_constraints(self, {{ model.name|lower }}):
        """Test unique constraints on {{ model.name }}."""
        # Try to create duplicate
        duplicate_data = {
            {% for field in model.fields %}
            {% if field.name in model.unique_fields %}
            '{{ field.name }}': {{ model.name|lower }}.{{ field.name }},
        {% else %}
        '{{ field.name }}': 'different_value',
        {% endif %}
        {% endfor %}
        }

        with pytest.raises(IntegrityError):
            {{ model.name }}.objects.create(**duplicate_data)
    {% endif %}

    {% if model.required_fields %}
    def test_required_fields(self):
        """Test required fields validation."""
        instance = {{ model.name }}()

        with pytest.raises(ValidationError) as excinfo:
            instance.full_clean()

        errors = excinfo.value.message_dict
        {% for field in model.required_fields %}
        assert '{{ field }}' in errors
    {% endfor %}
    {% endif %}

    {% if model.validation_methods %}
    def test_custom_validation(self, {{ model.name|lower }}):
        """Test custom validation methods."""
        # Test valid instance
        {{ model.name|lower }}.full_clean()  # Should not raise

        # Test invalid cases
        {% for validation in model.validation_methods %}
        # Test {{ validation.description }}
    {{ validation.test_invalid_case|indent(8) }}
    {% endfor %}
    {% endif %}

    {% if model.methods %}
    # Test model methods
    {% for method in model.methods %}
    def test_{{ method.name }}(self, {{ model.name|lower }}):
        """Test {{ method.name }} method."""
        {% if method.test_setup %}
        # Setup
        {{ method.test_setup|indent(8) }}
        {% endif %}

        # Execute
        result = {{ model.name|lower }}.{{ method.name }}({{ method.test_params|join(', ') if method.test_params }})

        # Assert
        {% if method.test_assertions %}
        {{ method.test_assertions|indent(8) }}
        {% else %}
        assert result is not None
    {% endif %}

    {% endfor %}
    {% endif %}

    {% if model.properties %}
    # Test model properties
    {% for prop in model.properties %}
    def test_{{ prop.name }}_property(self, {{ model.name|lower }}):
        """Test {{ prop.name }} property."""
        {% if prop.test_setup %}
        # Setup
        {{ prop.test_setup|indent(8) }}
        {% endif %}

        # Access property
        value = {{ model.name|lower }}.{{ prop.name }}

        # Assert
        {% if prop.test_assertions %}
        {{ prop.test_assertions|indent(8) }}
        {% else %}
        assert value is not None
    {% endif %}

    {% endfor %}
    {% endif %}

    {% if model.managers %}
    # Test custom managers
    {% for manager in model.managers %}
    def test_{{ manager.name }}_manager(self):
        """Test {{ manager.name }} manager."""
        from .factories import {{ model.name }}Factory

        # Create test data
        {{ manager.test_setup|indent(8) if manager.test_setup else model.name + 'Factory.create_batch(5)' }}

        # Test manager method
        queryset = {{ model.name }}.{{ manager.name }}.all()

        assert queryset.exists()
    {% if manager.test_assertions %}
    {{ manager.test_assertions|indent(8) }}
    {% endif %}

    {% endfor %}
    {% endif %}

    {% if model.features %}
    # Test model features
    {% if model.features.timestamps %}
    def test_timestamps(self, {{ model.name|lower }}):
        """Test timestamp fields."""
        assert {{ model.name|lower }}.created_at is not None
        assert {{ model.name|lower }}.updated_at is not None

        # Test auto-update
        original_updated = {{ model.name|lower }}.updated_at
        {{ model.name|lower }}.save()
        {{ model.name|lower }}.refresh_from_db()

        assert {{ model.name|lower }}.updated_at > original_updated
    {% endif %}

    {% if model.features.soft_delete %}
    def test_soft_delete(self, {{ model.name|lower }}):
        """Test soft delete functionality."""
        # Soft delete
        {{ model.name|lower }}.delete()

        # Verify soft deleted
        assert {{ model.name|lower }}.is_deleted is True
        assert {{ model.name|lower }}.deleted_at is not None

        # Verify still in database
        assert {{ model.name }}.objects.filter(pk={{ model.name|lower }}.pk).exists()

        # Test restore
        {{ model.name|lower }}.restore()
        assert {{ model.name|lower }}.is_deleted is False
        assert {{ model.name|lower }}.deleted_at is None
    {% endif %}

    {% if model.features.audit %}
    def test_audit_fields(self, {{ model.name|lower }}, user):
        """Test audit fields."""
        # Create with user
        instance = {{ model.name }}.objects.create(
            created_by=user,
            **factory.build(dict, FACTORY_CLASS={{ model.name }}Factory)
        )

        assert instance.created_by == user

        # Update with different user
        instance.updated_by = user
        instance.save()

        assert instance.updated_by == user
    {% endif %}

    {% if model.features.versioning %}
    def test_versioning(self, {{ model.name|lower }}):
        """Test version tracking."""
        initial_version = {{ model.name|lower }}.version
        initial_hash = {{ model.name|lower }}.version_hash

        # Change a field
        {% for field in model.fields[:1] %}
        {% if field.name not in ['id', 'created_at', 'updated_at', 'version', 'version_hash'] %}
        {{ model.name|lower }}.{{ field.name }} = 'Changed Value'
        {% endif %}
        {% endfor %}
        {{ model.name|lower }}.save()

        # Verify version incremented
        assert {{ model.name|lower }}.version == initial_version + 1
        assert {{ model.name|lower }}.version_hash != initial_hash
    {% endif %}
    {% endif %}

    {% if model.state_machine %}
    # Test state machine
    def test_state_transitions(self, {{ model.name|lower }}):
        """Test state machine transitions."""
        initial_state = {{ model.name|lower }}.{{ model.state_machine.field }}

        {% for transition in model.state_machine.transitions %}
        # Test {{ transition.name }} transition
        if '{{ initial_state }}' in {{ transition.source }}:
            {{ model.name|lower }}.{{ transition.name }}()
            assert {{ model.name|lower }}.{{ model.state_machine.field }} == '{{ transition.target }}'
    {% endfor %}

    def test_invalid_state_transition(self, {{ model.name|lower }}):
        """Test invalid state transitions."""
        # Try invalid transition
        {{ model.name|lower }}.{{ model.state_machine.field }} = '{{ model.state_machine.states[0] }}'
        {{ model.name|lower }}.save()

        # This should fail
        with pytest.raises(Exception):
            # Assuming there's a transition that's not valid from the first state
            pass
    {% endif %}

    # Test querysets
    def test_queryset_methods(self):
        """Test custom queryset methods."""
        from .factories import {{ model.name }}Factory

        # Create test data
        {{ model.name }}Factory.create_batch(10)

        {% if model.queryset_methods %}
        {% for method in model.queryset_methods %}
        # Test {{ method.name }}
        result = {{ model.name }}.objects.{{ method.name }}({{ method.test_params|join(', ') if method.test_params }})
        assert result.exists()
        {% endfor %}
        {% endif %}

        # Test chaining
        result = {{ model.name }}.objects.all()
        assert result.count() >= 10

    # Test database queries
    def test_database_queries(self, django_assert_num_queries, {{ model.name|lower }}):
        """Test database query optimization."""
        # Test select_related/prefetch_related
        with django_assert_num_queries(1):
            list({{ model.name }}.objects.all().optimized())

        # Test signals
        {% if model.signals %}
        def test_signals(self, {{ model.name|lower }}, mocker):
            """Test model signals."""
            {% for signal in model.signals %}
            # Mock {{ signal.name }} handler
            mock_handler = mocker.Mock()
            {{ signal.name }}.connect(mock_handler, sender={{ model.name }})

            # Trigger signal
            {{ signal.trigger_action|indent(8) }}

            # Verify signal was sent
            assert mock_handler.called
    {% endfor %}
    {% endif %}


    {% endfor %}

    # Test model relationships
    @pytest.mark.django_db
    class TestModelRelationships:
        """Test relationships between models."""

        {% for model in models %}
        {% for field in model.fields %}
        {% if field.type in ['ForeignKey', 'OneToOneField', 'ManyToManyField'] %}
        def test_{{ model.name|lower }}_{{ field.name }}_relationship(self, {{ model.name|lower }}_with_relations):
            """Test {{ model.name }}.{{ field.name }} relationship."""
            instance = {{ model.name|lower }}_with_relations

            {% if field.type == 'ForeignKey' %}
            # Test forward relationship
            assert instance.{{ field.name }} is not None
            assert isinstance(instance.{{ field.name }}, {{ field.to }})

            # Test reverse relationship
            {% if field.related_name %}
            assert instance in instance.{{ field.name }}.{{ field.related_name }}.all()
            {% else %}
            assert instance in instance.{{ field.name }}.{{ model.name|lower }}_set.all()
            {% endif %}

            {% elif field.type == 'OneToOneField' %}
            # Test one-to-one relationship
            assert hasattr(instance, '{{ field.name }}')
            related = getattr(instance, '{{ field.name }}', None)
            if related:
                assert isinstance(related, {{ field.to }})
                {% if field.related_name %}
                assert getattr(related, '{{ field.related_name }}') == instance
                {% else %}
                assert getattr(related, '{{ model.name|lower }}') == instance
            {% endif %}

            {% elif field.type == 'ManyToManyField' %}
            # Test many-to-many relationship
            assert instance.{{ field.name }}.exists()
            for related in instance.{{ field.name }}.all():
                assert isinstance(related, {{ field.to }})
                {% if field.related_name %}
                assert instance in related.{{ field.related_name }}.all()
                {% else %}
                assert instance in related.{{ model.name|lower }}_set.all()
    {% endif %}
    {% endif %}

    {% endif %}
    {% endfor %}
    {% endfor %}