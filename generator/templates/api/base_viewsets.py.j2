"""
Base ViewSet classes for {{ project.name }} project.

Generated by Django Enhanced Generator on {{ now().strftime('%Y-%m-%d %H:%M:%S') }}.
"""
from rest_framework import viewsets, status
from rest_framework.response import Response
from rest_framework.decorators import action
from django.db import transaction
from django.core.exceptions import ValidationError
{% if features.get('enterprise', {}).get('multitenancy') %}
from django_tenants.utils import tenant_context
{% endif %}
{% if features.get('enterprise', {}).get('audit') %}
from core.audit.mixins import AuditMixin
{% endif %}
{% if features.get('monitoring', {}).get('logging') %}
import logging

logger = logging.getLogger(__name__)
{% endif %}


class BaseViewSet(viewsets.ModelViewSet):
    """
    Base ViewSet with common functionality for all API views.
    """

    def get_serializer_context(self):
        """Add request user and other context to serializer."""
        context = super().get_serializer_context()
        context['user'] = self.request.user if self.request else None
        {% if features.get('enterprise', {}).get('multitenancy') %}
        context['tenant'] = self.request.tenant if hasattr(self.request, 'tenant') else None
        {% endif %}
        return context

    def perform_create(self, serializer):
        """Add audit fields on create."""
        kwargs = {}
        {% if features.get('enterprise', {}).get('audit') %}
        if hasattr(serializer.Meta.model, 'created_by'):
            kwargs['created_by'] = self.request.user
        {% endif %}
        {% if features.get('enterprise', {}).get('multitenancy') %}
        if hasattr(serializer.Meta.model, 'tenant'):
            kwargs['tenant'] = self.request.tenant
        {% endif %}
        serializer.save(**kwargs)

    def perform_update(self, serializer):
        """Add audit fields on update."""
        kwargs = {}
        {% if features.get('enterprise', {}).get('audit') %}
        if hasattr(serializer.Meta.model, 'updated_by'):
            kwargs['updated_by'] = self.request.user
        {% endif %}
        serializer.save(**kwargs)

    {% if features.get('monitoring', {}).get('logging') %}
    def dispatch(self, request, *args, **kwargs):
        """Log API requests."""
        logger.info(
            f"API Request: {request.method} {request.path} by {request.user}",
            extra={
                'method': request.method,
                'path': request.path,
                'user': str(request.user),
                'ip': self.get_client_ip(request),
            }
        )
        return super().dispatch(request, *args, **kwargs)

    def get_client_ip(self, request):
        """Get client IP from request."""
        x_forwarded_for = request.META.get('HTTP_X_FORWARDED_FOR')
        if x_forwarded_for:
            ip = x_forwarded_for.split(',')[0]
        else:
            ip = request.META.get('REMOTE_ADDR')
        return ip
{% endif %}


{% if features.get('enterprise', {}).get('multitenancy') %}
class TenantViewSet(BaseViewSet):
    """
    ViewSet that filters by tenant automatically.
    """

    def get_queryset(self):
        """Filter queryset by current tenant."""
        queryset = super().get_queryset()

        if hasattr(self.request, 'tenant') and hasattr(queryset.model, 'tenant'):
            queryset = queryset.filter(tenant=self.request.tenant)

        return queryset

    def perform_create(self, serializer):
        """Ensure object is created for current tenant."""
        kwargs = {}

        if hasattr(serializer.Meta.model, 'tenant'):
            kwargs['tenant'] = self.request.tenant

        if hasattr(serializer.Meta.model, 'created_by'):
            kwargs['created_by'] = self.request.user

        serializer.save(**kwargs)
{% endif %}


class BulkModelViewSet(BaseViewSet):
    """
    ViewSet with bulk operations support.
    """

    @action(detail=False, methods=['post'])
    @transaction.atomic
    def bulk_create(self, request):
        """
        Create multiple objects in one request.
        """
        serializer = self.get_serializer(data=request.data, many=True)
        serializer.is_valid(raise_exception=True)

        self.perform_bulk_create(serializer)

        return Response(
            serializer.data,
            status=status.HTTP_201_CREATED
        )

    def perform_bulk_create(self, serializer):
        """Perform the bulk creation."""
        objects = []

        for item in serializer.validated_data:
        {% if features.get('enterprise', {}).get('audit') %}
            if hasattr(self.queryset.model, 'created_by'):
                item['created_by'] = self.request.user
            {% endif %}
            {% if features.get('enterprise', {}).get('multitenancy') %}
            if hasattr(self.queryset.model, 'tenant'):
                item['tenant'] = self.request.tenant
            {% endif %}
            objects.append(self.queryset.model(**item))

        self.queryset.model.objects.bulk_create(objects)

    @action(detail=False, methods=['post'])
    @transaction.atomic
    def bulk_update(self, request):
        """
        Update multiple objects in one request.
        """
        data = request.data

        if not isinstance(data, list):
            return Response(
                {'error': 'Expected a list of objects'},
                status=status.HTTP_400_BAD_REQUEST
            )

        updated = []
        errors = []

        for item in data:
            try:
                instance = self.queryset.get(pk=item.get('id'))
                serializer = self.get_serializer(
                    instance,
                    data=item,
                    partial=True
                )
                serializer.is_valid(raise_exception=True)
                self.perform_update(serializer)
                updated.append(serializer.data)
            except Exception as e:
                errors.append({
                    'id': item.get('id'),
                    'error': str(e)
                })

        return Response({
            'updated': updated,
            'errors': errors
        })

    @action(detail=False, methods=['post'])
    @transaction.atomic
    def bulk_delete(self, request):
        """
        Delete multiple objects in one request.
        """
        ids = request.data.get('ids', [])

        if not ids:
            return Response(
                {'error': 'No IDs provided'},
                status=status.HTTP_400_BAD_REQUEST
            )

        # Get objects to delete
        objects = self.queryset.filter(pk__in=ids)

        {% if features.get('api', {}).get('soft_delete') %}
        # Soft delete
        count = objects.update(
            is_deleted=True,
            {% if features.get('enterprise', {}).get('audit') %}
            deleted_by=self.request.user,
            deleted_at=timezone.now()
            {% endif %}
        )
        {% else %}
        # Hard delete
        count, _ = objects.delete()
        {% endif %}

        return Response({
            'deleted': count,
            'ids': ids
        })


class SoftDeleteMixin:
    """
    Mixin for soft delete functionality.
    """

    def perform_destroy(self, instance):
        """Soft delete instead of hard delete."""
        instance.is_deleted = True
        {% if features.get('enterprise', {}).get('audit') %}
        if hasattr(instance, 'deleted_by'):
            instance.deleted_by = self.request.user
        if hasattr(instance, 'deleted_at'):
            from django.utils import timezone
            instance.deleted_at = timezone.now()
        {% endif %}
        instance.save()

    def get_queryset(self):
        """Filter out soft deleted objects by default."""
        queryset = super().get_queryset()

        # Allow viewing deleted items with query param
        if self.request.query_params.get('include_deleted') == 'true':
            return queryset

        if hasattr(queryset.model, 'is_deleted'):
            queryset = queryset.filter(is_deleted=False)

        return queryset


class ReadOnlyViewSet(viewsets.ReadOnlyModelViewSet):
    """
    ViewSet that only allows read operations.
    """
    pass


class NestedViewSetMixin:
    """
    Mixin for handling nested resources.
    """

    parent_lookup_field = 'parent_pk'
    parent_model = None
    parent_relation_field = 'parent'

    def get_parent_object(self):
        """Get the parent object."""
        if not self.parent_model:
            raise ValueError('parent_model must be set')

        parent_pk = self.kwargs.get(self.parent_lookup_field)
        return self.parent_model.objects.get(pk=parent_pk)

    def get_queryset(self):
        """Filter by parent object."""
        queryset = super().get_queryset()

        if self.parent_lookup_field in self.kwargs:
            parent = self.get_parent_object()
            filter_kwargs = {self.parent_relation_field: parent}
            queryset = queryset.filter(**filter_kwargs)

        return queryset

    def perform_create(self, serializer):
        """Set parent on create."""
        kwargs = {}

        if self.parent_lookup_field in self.kwargs:
            parent = self.get_parent_object()
            kwargs[self.parent_relation_field] = parent

        super().perform_create(serializer, **kwargs)


{% if features.get('enterprise', {}).get('audit') %}
class AuditedViewSet(AuditMixin, BaseViewSet):
    """
    ViewSet with full audit trail support.
    """

    def perform_create(self, serializer):
        """Create with audit."""
        instance = serializer.save(created_by=self.request.user)
        self.log_action('created', instance)

    def perform_update(self, serializer):
        """Update with audit."""
        instance = serializer.save(updated_by=self.request.user)
        self.log_action('updated', instance)

    def perform_destroy(self, instance):
        """Delete with audit."""
        self.log_action('deleted', instance)
        super().perform_destroy(instance)
{% endif %}


class CachedViewSetMixin:
    """
    Mixin for caching ViewSet responses.
    """

    cache_timeout = 300  # 5 minutes default

    def get_cache_key(self, request):
        """Generate cache key for request."""
        from django.core.cache import cache
        import hashlib

        # Include user ID for user-specific caching
        user_id = request.user.id if request.user.is_authenticated else 'anon'

        # Create cache key from request details
        key_parts = [
            self.__class__.__name__,
            request.method,
            request.path,
            str(user_id),
            str(sorted(request.query_params.items())),
        ]

        key_string = ':'.join(key_parts)
        return hashlib.md5(key_string.encode()).hexdigest()

    def list(self, request, *args, **kwargs):
        """Cache list responses."""
        from django.core.cache import cache

        if request.method != 'GET':
            return super().list(request, *args, **kwargs)

        cache_key = self.get_cache_key(request)
        cached_response = cache.get(cache_key)

        if cached_response is not None:
            return Response(cached_response)

        response = super().list(request, *args, **kwargs)

        if response.status_code == 200:
            cache.set(cache_key, response.data, self.cache_timeout)

        return response

    def retrieve(self, request, *args, **kwargs):
        """Cache retrieve responses."""
        from django.core.cache import cache

        if request.method != 'GET':
            return super().retrieve(request, *args, **kwargs)

        cache_key = self.get_cache_key(request)
        cached_response = cache.get(cache_key)

        if cached_response is not None:
            return Response(cached_response)

        response = super().retrieve(request, *args, **kwargs)

        if response.status_code == 200:
            cache.set(cache_key, response.data, self.cache_timeout)

        return response