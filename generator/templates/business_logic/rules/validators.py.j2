"""
Business rule validators for {{ app_name }} app.

Generated by Django Enhanced Generator on {{ now().strftime('%Y-%m-%d %H:%M:%S') }}.
"""
from typing import Any, Optional, List, Dict, Callable, Type
from decimal import Decimal
from datetime import datetime, date, timedelta
from django.core.exceptions import ValidationError
from django.core.validators import RegexValidator, EmailValidator, URLValidator
from django.utils import timezone
from django.db import models
import re
import logging

logger = logging.getLogger(__name__)


class RuleValidator:
    """Base class for rule validators."""

    # Registry of validators
    _validators: Dict[str, Callable] = {}

    @classmethod
    def register(cls, name: str, validator: Callable):
        """Register a validator."""
        cls._validators[name] = validator

    @classmethod
    def get_validator(cls, name: str) -> Optional[Callable]:
        """Get validator by name."""
        return cls._validators.get(name)

    @classmethod
    def list_validators(cls) -> List[str]:
        """List all registered validators."""
        return list(cls._validators.keys())


# Common validators
def required_validator(value: Any, field_name: str = "Field", **kwargs) -> None:
    """Validate that value is not empty."""
    if value is None or value == "":
        raise ValidationError(f"{field_name} is required")


def length_validator(value: str, min_length: Optional[int] = None, max_length: Optional[int] = None,
                     field_name: str = "Field", **kwargs) -> None:
    """Validate string length."""
    if not isinstance(value, str):
        value = str(value)

    length = len(value)

    if min_length is not None and length < min_length:
        raise ValidationError(f"{field_name} must be at least {min_length} characters long")

    if max_length is not None and length > max_length:
        raise ValidationError(f"{field_name} must be at most {max_length} characters long")


def range_validator(value: Any, min_value: Optional[Any] = None, max_value: Optional[Any] = None,
                    field_name: str = "Field", **kwargs) -> None:
    """Validate numeric range."""
    if min_value is not None and value < min_value:
        raise ValidationError(f"{field_name} must be at least {min_value}")

    if max_value is not None and value > max_value:
        raise ValidationError(f"{field_name} must be at most {max_value}")


def regex_validator(value: str, pattern: str, field_name: str = "Field",
                    message: Optional[str] = None, **kwargs) -> None:
    """Validate against regex pattern."""
    if not re.match(pattern, str(value)):
        if message:
            raise ValidationError(message)
        else:
            raise ValidationError(f"{field_name} does not match required pattern")


def email_validator(value: str, **kwargs) -> None:
    """Validate email address."""
    validator = EmailValidator()
    try:
        validator(value)
    except ValidationError:
        raise ValidationError("Enter a valid email address")


def url_validator(value: str, **kwargs) -> None:
    """Validate URL."""
    validator = URLValidator()
    try:
        validator(value)
    except ValidationError:
        raise ValidationError("Enter a valid URL")


def date_validator(value: Any, min_date: Optional[date] = None, max_date: Optional[date] = None,
                   field_name: str = "Date", **kwargs) -> None:
    """Validate date value."""
    if isinstance(value, datetime):
        value = value.date()
    elif not isinstance(value, date):
        raise ValidationError(f"{field_name} must be a valid date")

    if min_date and value < min_date:
        raise ValidationError(f"{field_name} cannot be before {min_date}")

    if max_date and value > max_date:
        raise ValidationError(f"{field_name} cannot be after {max_date}")


def future_date_validator(value: Any, field_name: str = "Date", **kwargs) -> None:
    """Validate that date is in the future."""
    if isinstance(value, datetime):
        value = value.date()

    if value <= timezone.now().date():
        raise ValidationError(f"{field_name} must be in the future")


def past_date_validator(value: Any, field_name: str = "Date", **kwargs) -> None:
    """Validate that date is in the past."""
    if isinstance(value, datetime):
        value = value.date()

    if value >= timezone.now().date():
        raise ValidationError(f"{field_name} must be in the past")


def choice_validator(value: Any, choices: List[Any], field_name: str = "Field", **kwargs) -> None:
    """Validate against list of choices."""
    if value not in choices:
        raise ValidationError(f"{field_name} must be one of: {', '.join(str(c) for c in choices)}")


def unique_together_validator(instance: models.Model, fields: List[str], **kwargs) -> None:
    """Validate unique together constraint."""
    model = instance.__class__

    # Build filter
    filter_kwargs = {}
    for field in fields:
        filter_kwargs[field] = getattr(instance, field)

    # Exclude current instance if updating
    qs = model.objects.filter(**filter_kwargs)
    if instance.pk:
        qs = qs.exclude(pk=instance.pk)

    if qs.exists():
        field_names = ", ".join(fields)
        raise ValidationError(f"The combination of {field_names} must be unique")


# Business-specific validators
{% for model in models %}
{% if model.validators %}
# {{ model.name }} validators
{% for validator in model.validators %}
def {{ validator.name }}(instance: '{{ model.name }}', **kwargs) -> None:
    """{{ validator.description }}"""
{{ validator.implementation|indent(4) }}


{% endfor %}
{% endif %}
{% endfor %}

# Complex validators
def conditional_required_validator(instance: models.Model, field: str, condition_field: str,
                                   condition_value: Any, **kwargs) -> None:
    """Validate field is required when another field has specific value."""
    if getattr(instance, condition_field) == condition_value:
        value = getattr(instance, field)
        if value is None or value == "":
            raise ValidationError(f"{field} is required when {condition_field} is {condition_value}")


def mutual_exclusion_validator(instance: models.Model, fields: List[str], **kwargs) -> None:
    """Validate that only one of the fields can have a value."""
    filled_fields = []

    for field in fields:
        value = getattr(instance, field)
        if value is not None and value != "":
            filled_fields.append(field)

    if len(filled_fields) > 1:
        raise ValidationError(f"Only one of {', '.join(fields)} can be specified")
    elif len(filled_fields) == 0:
        raise ValidationError(f"At least one of {', '.join(fields)} must be specified")


def dependency_validator(instance: models.Model, field: str, depends_on: str, **kwargs) -> None:
    """Validate that field can only be set if depends_on field is set."""
    field_value = getattr(instance, field)
    depends_value = getattr(instance, depends_on)

    if field_value and not depends_value:
        raise ValidationError(f"{field} can only be set when {depends_on} is provided")


def sum_validator(instance: models.Model, fields: List[str], expected_sum: Any,
                  tolerance: float = 0.01, **kwargs) -> None:
    """Validate that sum of fields equals expected value."""
    total = sum(getattr(instance, field) or 0 for field in fields)

    if abs(total - expected_sum) > tolerance:
        raise ValidationError(f"Sum of {', '.join(fields)} must equal {expected_sum}")


def percentage_validator(value: Any, field_name: str = "Percentage", **kwargs) -> None:
    """Validate percentage value (0-100)."""
    if not 0 <= value <= 100:
        raise ValidationError(f"{field_name} must be between 0 and 100")


def file_extension_validator(value: Any, allowed_extensions: List[str], **kwargs) -> None:
    """Validate file extension."""
    if hasattr(value, 'name'):
        filename = value.name
        extension = filename.split('.')[-1].lower()

        if extension not in allowed_extensions:
            raise ValidationError(
                f"File must have one of the following extensions: {', '.join(allowed_extensions)}"
            )


def file_size_validator(value: Any, max_size_mb: float, **kwargs) -> None:
    """Validate file size."""
    if hasattr(value, 'size'):
        size_mb = value.size / (1024 * 1024)

        if size_mb > max_size_mb:
            raise ValidationError(f"File size must not exceed {max_size_mb}MB")


# Register validators
RuleValidator.register('required', required_validator)
RuleValidator.register('length', length_validator)
RuleValidator.register('range', range_validator)
RuleValidator.register('regex', regex_validator)
RuleValidator.register('email', email_validator)
RuleValidator.register('url', url_validator)
RuleValidator.register('date', date_validator)
RuleValidator.register('future_date', future_date_validator)
RuleValidator.register('past_date', past_date_validator)
RuleValidator.register('choice', choice_validator)
RuleValidator.register('unique_together', unique_together_validator)
RuleValidator.register('conditional_required', conditional_required_validator)
RuleValidator.register('mutual_exclusion', mutual_exclusion_validator)
RuleValidator.register('dependency', dependency_validator)
RuleValidator.register('sum', sum_validator)
RuleValidator.register('percentage', percentage_validator)
RuleValidator.register('file_extension', file_extension_validator)
RuleValidator.register('file_size', file_size_validator)

{% for model in models %}
{% if model.validators %}
{% for validator in model.validators %}
RuleValidator.register('{{ validator.name }}', {{ validator.name }})
{% endfor %}
{% endif %}
{% endfor %}


# Validator builder
class ValidatorBuilder:
    """Builder for creating complex validators."""

    def __init__(self):
        self.validators: List[Callable] = []

    def add_validator(self, validator: Callable, **params) -> 'ValidatorBuilder':
        """Add a validator with parameters."""
        if params:
            def wrapped_validator(instance):
                return validator(instance, **params)
            self.validators.append(wrapped_validator)
        else:
            self.validators.append(validator)

        return self

    def build(self) -> Callable:
        """Build composite validator."""
        def composite_validator(instance):
            errors = []

            for validator in self.validators:
                try:
                    validator(instance)
                except ValidationError as e:
                    errors.extend(e.messages if hasattr(e, 'messages') else [str(e)])

            if errors:
                raise ValidationError(errors)

        return composite_validator


# Validation mixins
class ValidationMixin:
    """Mixin to add validation capabilities to models."""

    def validate_field(self, field_name: str, validator_name: str, **params):
        """Validate a single field."""
        validator = RuleValidator.get_validator(validator_name)
        if not validator:
            raise ValueError(f"Unknown validator: {validator_name}")

        value = getattr(self, field_name)
        validator(value, field_name=field_name, **params)

    def run_validators(self, validators: List[Dict[str, Any]]):
        """Run multiple validators."""
        errors = []

        for validator_config in validators:
            validator_name = validator_config.get('name')
            params = validator_config.get('params', {})

            validator = RuleValidator.get_validator(validator_name)
            if validator:
                try:
                    validator(self, **params)
                except ValidationError as e:
                    errors.extend(e.messages if hasattr(e, 'messages') else [str(e)])

        if errors:
            raise ValidationError(errors)