"""
Business rule engine for {{ app_name }} app.

Generated by Django Enhanced Generator on {{ now().strftime('%Y-%m-%d %H:%M:%S') }}.
"""
from typing import Dict, List, Any, Optional, Callable, Type
from dataclasses import dataclass, field
from enum import Enum
from django.db import models, transaction
from django.core.exceptions import ValidationError
from django.contrib.auth import get_user_model
from django.utils import timezone
from django.core.cache import cache
import logging
import json
{% if features.celery %}
from celery import shared_task
{% endif %}

# Local imports
from .conditions import Condition, ConditionGroup, ConditionOperator, evaluate_conditions
from .validators import RuleValidator
from ..models import *

logger = logging.getLogger(__name__)
User = get_user_model()


class RuleType(Enum):
    """Types of business rules."""
    VALIDATION = "validation"
    CALCULATION = "calculation"
    ASSIGNMENT = "assignment"
    WORKFLOW = "workflow"
    NOTIFICATION = "notification"
    PERMISSION = "permission"
    CONSTRAINT = "constraint"


class RulePriority(Enum):
    """Rule execution priority."""
    CRITICAL = 1
    HIGH = 10
    NORMAL = 50
    LOW = 100


class RuleExecutionMode(Enum):
    """When rules should be executed."""
    SYNC = "sync"
    ASYNC = "async"
    SCHEDULED = "scheduled"


@dataclass
class RuleAction:
    """Action to execute when rule conditions are met."""
    type: str
    target: Optional[str] = None
    value: Optional[Any] = None
    params: Dict[str, Any] = field(default_factory=dict)

    def execute(self, context: Dict[str, Any]) -> Any:
        """Execute the action."""
        if self.type == "set_field":
            return self._set_field(context)
        elif self.type == "calculate":
            return self._calculate(context)
        elif self.type == "validate":
            return self._validate(context)
        elif self.type == "workflow":
            return self._trigger_workflow(context)
        elif self.type == "notification":
            return self._send_notification(context)
        elif self.type == "custom":
            return self._custom_action(context)
        else:
            raise ValueError(f"Unknown action type: {self.type}")

    def _set_field(self, context: Dict[str, Any]) -> Any:
        """Set field value."""
        instance = context.get('instance')
        if instance and self.target:
            setattr(instance, self.target, self.value)
            return self.value
        return None

    def _calculate(self, context: Dict[str, Any]) -> Any:
        """Perform calculation."""
        # Implement calculation logic based on params
        expression = self.params.get('expression')
        if expression:
            # Safe evaluation of expression
            return eval(expression, {"__builtins__": {}}, context)
        return None

    def _validate(self, context: Dict[str, Any]) -> bool:
        """Perform validation."""
        validator_name = self.params.get('validator')
        if validator_name:
            validator = RuleValidator.get_validator(validator_name)
            if validator:
                return validator(context.get('instance'), **self.params)
        return True

    def _trigger_workflow(self, context: Dict[str, Any]) -> Any:
        """Trigger workflow."""
        workflow_name = self.params.get('workflow')
        # Implementation depends on workflow system
        logger.info(f"Triggering workflow: {workflow_name}")
        return None

    def _send_notification(self, context: Dict[str, Any]) -> Any:
        """Send notification."""
        # Implementation depends on notification system
        logger.info(f"Sending notification: {self.params}")
        return None

    def _custom_action(self, context: Dict[str, Any]) -> Any:
        """Execute custom action."""
        func_name = self.params.get('function')
        if func_name:
            # Get function from registry or module
            func = globals().get(func_name)
            if func and callable(func):
                return func(context, **self.params)
        return None


@dataclass
class Rule:
    """Business rule definition."""
    name: str
    description: str
    type: RuleType
    conditions: List[Union[Condition, ConditionGroup]]
    actions: List[RuleAction]
    priority: RulePriority = RulePriority.NORMAL
    enabled: bool = True
    mode: RuleExecutionMode = RuleExecutionMode.SYNC
    metadata: Dict[str, Any] = field(default_factory=dict)

    def evaluate_conditions(self, context: Dict[str, Any]) -> bool:
        """Evaluate all conditions."""
        if not self.conditions:
            return True

        return all(condition.evaluate(context) for condition in self.conditions)

    def execute(self, context: Dict[str, Any]) -> List[Any]:
        """Execute rule if conditions are met."""
        if not self.enabled:
            logger.debug(f"Rule {self.name} is disabled")
            return []

        if not self.evaluate_conditions(context):
            logger.debug(f"Rule {self.name} conditions not met")
            return []

        logger.info(f"Executing rule: {self.name}")
        results = []

        for action in self.actions:
            try:
                result = action.execute(context)
                results.append(result)
            except Exception as e:
                logger.error(f"Error executing action in rule {self.name}: {e}")
                if self.type == RuleType.VALIDATION:
                    raise

        return results


class RuleEngine:
    """Main rule engine for executing business rules."""

    def __init__(self):
        self.rules: Dict[str, List[Rule]] = {}
        self._cache_timeout = 300  # 5 minutes

    def register_rule(self, model_name: str, rule: Rule):
        """Register a rule for a model."""
        if model_name not in self.rules:
            self.rules[model_name] = []

        self.rules[model_name].append(rule)

        # Sort by priority
        self.rules[model_name].sort(key=lambda r: r.priority.value)

        # Invalidate cache
        self._invalidate_cache(model_name)

    def unregister_rule(self, model_name: str, rule_name: str):
        """Unregister a rule."""
        if model_name in self.rules:
            self.rules[model_name] = [
                r for r in self.rules[model_name] if r.name != rule_name
            ]
            self._invalidate_cache(model_name)

    def get_rules_for_model(self, model_name: str, rule_type: Optional[RuleType] = None) -> List[Rule]:
        """Get rules for a specific model."""
        cache_key = f"rule_engine:{model_name}:{rule_type.value if rule_type else 'all'}"

        # Try cache first
        cached_rules = cache.get(cache_key)
        if cached_rules is not None:
            return cached_rules

        rules = self.rules.get(model_name, [])

        if rule_type:
            rules = [r for r in rules if r.type == rule_type]

        # Cache the result
        cache.set(cache_key, rules, self._cache_timeout)

        return rules

    @transaction.atomic
    def execute_rules(self, instance: models.Model, rule_type: Optional[RuleType] = None,
                      context: Optional[Dict[str, Any]] = None) -> Dict[str, List[Any]]:
        """Execute rules for a model instance."""
        model_name = instance.__class__.__name__
        rules = self.get_rules_for_model(model_name, rule_type)

        if not rules:
            return {}

        # Build context
        full_context = {
            'instance': instance,
            'model_name': model_name,
            'user': getattr(instance, '_current_user', None),
            'timestamp': timezone.now(),
            **(context or {})
        }

        results = {}

        # Execute sync rules
        sync_rules = [r for r in rules if r.mode == RuleExecutionMode.SYNC]
        for rule in sync_rules:
            try:
                rule_results = rule.execute(full_context)
                results[rule.name] = rule_results
            except ValidationError:
                raise
            except Exception as e:
                logger.error(f"Error executing rule {rule.name}: {e}")
                if rule.type == RuleType.VALIDATION:
                    raise ValidationError(f"Rule {rule.name} failed: {str(e)}")

        # Queue async rules
        async_rules = [r for r in rules if r.mode == RuleExecutionMode.ASYNC]
        for rule in async_rules:
        {% if features.celery %}
            execute_rule_async.delay(
                rule_name=rule.name,
                model_name=model_name,
                instance_id=instance.pk,
                context=context
            )
            {% else %}
            # Execute synchronously if Celery not available
            try:
                rule_results = rule.execute(full_context)
                results[rule.name] = rule_results
            except Exception as e:
                logger.error(f"Error executing async rule {rule.name}: {e}")
        {% endif %}

        return results

    def validate_instance(self, instance: models.Model) -> List[str]:
        """Run validation rules and return errors."""
        results = self.execute_rules(instance, RuleType.VALIDATION)

        errors = []
        for rule_name, rule_results in results.items():
            for result in rule_results:
                if isinstance(result, str):
                    errors.append(result)
                elif isinstance(result, (list, tuple)):
                    errors.extend(str(r) for r in result)
                elif result is False:
                    errors.append(f"Validation rule {rule_name} failed")

        return errors

    def _invalidate_cache(self, model_name: str):
        """Invalidate cache for model rules."""
        cache.delete_pattern(f"rule_engine:{model_name}:*")


# Global rule engine instance
rule_engine = RuleEngine()


# Rule definitions
{% for model in models %}
{% if model.rules %}
# {{ model.name }} rules
{% for rule_def in model.rules %}
{{ rule_def.name }}_rule = Rule(
    name="{{ rule_def.name }}",
    description="{{ rule_def.description }}",
    type=RuleType.{{ rule_def.type|upper }},
    conditions=[
        {% for condition in rule_def.conditions %}
        Condition(
            field="{{ condition.field }}",
            operator=ConditionOperator.{{ condition.operator|upper }},
            value={{ condition.value|repr }}
        ),
        {% endfor %}
    ],
    actions=[
        {% for action in rule_def.actions %}
        RuleAction(
            type="{{ action.type }}",
            {% if action.target %}target="{{ action.target }}",{% endif %}
            {% if action.value %}value={{ action.value|repr }},{% endif %}
            params={{ action.params|default({}) }}
        ),
        {% endfor %}
    ],
    priority=RulePriority.{{ rule_def.priority|default('NORMAL')|upper }},
    enabled={{ rule_def.enabled|default(True) }},
    mode=RuleExecutionMode.{{ rule_def.mode|default('SYNC')|upper }}
)

# Register rule
rule_engine.register_rule('{{ model.name }}', {{ rule_def.name }}_rule)

{% endfor %}
{% endif %}
{% endfor %}

# Async task for rule execution
{% if features.celery %}
@shared_task
def execute_rule_async(rule_name: str, model_name: str, instance_id: int, context: Optional[Dict[str, Any]] = None):
    """Execute rule asynchronously."""
    try:
        # Get model class
        model_class = globals().get(model_name)
        if not model_class:
            logger.error(f"Model class {model_name} not found")
            return

        # Get instance
        instance = model_class.objects.get(pk=instance_id)

        # Get rule
        rules = rule_engine.get_rules_for_model(model_name)
        rule = next((r for r in rules if r.name == rule_name), None)

        if not rule:
            logger.error(f"Rule {rule_name} not found")
            return

        # Build context
        full_context = {
            'instance': instance,
            'model_name': model_name,
            'timestamp': timezone.now(),
            **(context or {})
        }

        # Execute rule
        rule.execute(full_context)

    except Exception as e:
        logger.error(f"Error executing async rule {rule_name}: {e}")
{% endif %}


# Model mixins
class RuleEngineMixin:
    """Mixin to integrate rule engine with models."""

    def apply_rules(self, rule_type: Optional[RuleType] = None, context: Optional[Dict[str, Any]] = None):
        """Apply rules to this instance."""
        return rule_engine.execute_rules(self, rule_type, context)

    def validate_with_rules(self):
        """Validate instance using rule engine."""
        errors = rule_engine.validate_instance(self)
        if errors:
            raise ValidationError(errors)

    def clean(self):
        """Override clean to include rule validation."""
        super().clean()
        self.validate_with_rules()


# Decorators
def apply_rules(rule_type: RuleType = None):
    """Decorator to apply rules after method execution."""
    def decorator(func):
        def wrapper(self, *args, **kwargs):
            result = func(self, *args, **kwargs)

            # Apply rules
            if hasattr(self, 'apply_rules'):
                self.apply_rules(rule_type)

            return result
        return wrapper
    return decorator


def validate_with_rules(func):
    """Decorator to validate with rules before method execution."""
    def wrapper(self, *args, **kwargs):
        # Validate
        if hasattr(self, 'validate_with_rules'):
            self.validate_with_rules()

        return func(self, *args, **kwargs)
    return wrapper