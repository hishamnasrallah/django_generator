"""
Business rule conditions for {{ app_name }} app.

Generated by Django Enhanced Generator on {{ now().strftime('%Y-%m-%d %H:%M:%S') }}.
"""
from typing import Any, Dict, List, Optional, Callable, Union
from dataclasses import dataclass
from enum import Enum
from decimal import Decimal
from datetime import datetime, date, timedelta
from django.utils import timezone
from django.contrib.auth import get_user_model
import operator
import re
import logging

logger = logging.getLogger(__name__)
User = get_user_model()


class ConditionOperator(Enum):
    """Supported condition operators."""
    # Comparison
    EQUALS = "equals"
    NOT_EQUALS = "not_equals"
    GREATER_THAN = "greater_than"
    GREATER_THAN_OR_EQUAL = "greater_than_or_equal"
    LESS_THAN = "less_than"
    LESS_THAN_OR_EQUAL = "less_than_or_equal"

    # String operations
    CONTAINS = "contains"
    NOT_CONTAINS = "not_contains"
    STARTS_WITH = "starts_with"
    ENDS_WITH = "ends_with"
    MATCHES_REGEX = "matches_regex"

    # Collection operations
    IN = "in"
    NOT_IN = "not_in"

    # Logical operations
    AND = "and"
    OR = "or"
    NOT = "not"

    # Special operations
    IS_NULL = "is_null"
    IS_NOT_NULL = "is_not_null"
    IS_EMPTY = "is_empty"
    IS_NOT_EMPTY = "is_not_empty"

    # Date operations
    DATE_BEFORE = "date_before"
    DATE_AFTER = "date_after"
    DATE_BETWEEN = "date_between"
    AGE_GREATER_THAN = "age_greater_than"
    AGE_LESS_THAN = "age_less_than"


@dataclass
class Condition:
    """Single condition in a rule."""
    field: str
    operator: ConditionOperator
    value: Any
    case_sensitive: bool = True
    negate: bool = False

    def evaluate(self, context: Dict[str, Any]) -> bool:
        """Evaluate this condition against context."""
        try:
            field_value = self._get_field_value(context, self.field)
            result = self._evaluate_operator(field_value, self.operator, self.value)

            return not result if self.negate else result

        except Exception as e:
            logger.error(f"Error evaluating condition: {e}")
            return False

    def _get_field_value(self, context: Dict[str, Any], field_path: str) -> Any:
        """Get value from context using dot notation."""
        parts = field_path.split('.')
        value = context

        for part in parts:
            if isinstance(value, dict):
                value = value.get(part)
            elif hasattr(value, part):
                value = getattr(value, part)
            else:
                return None

        return value

    def _evaluate_operator(self, field_value: Any, op: ConditionOperator, comparison_value: Any) -> bool:
        """Evaluate operator on values."""
        # Handle None values
        if op == ConditionOperator.IS_NULL:
            return field_value is None
        elif op == ConditionOperator.IS_NOT_NULL:
            return field_value is not None
        elif field_value is None:
            return False

        # String operations
        if op in [ConditionOperator.CONTAINS, ConditionOperator.NOT_CONTAINS,
                  ConditionOperator.STARTS_WITH, ConditionOperator.ENDS_WITH]:
            field_str = str(field_value)
            comp_str = str(comparison_value)

            if not self.case_sensitive:
                field_str = field_str.lower()
                comp_str = comp_str.lower()

            if op == ConditionOperator.CONTAINS:
                return comp_str in field_str
            elif op == ConditionOperator.NOT_CONTAINS:
                return comp_str not in field_str
            elif op == ConditionOperator.STARTS_WITH:
                return field_str.startswith(comp_str)
            elif op == ConditionOperator.ENDS_WITH:
                return field_str.endswith(comp_str)

        # Regex matching
        elif op == ConditionOperator.MATCHES_REGEX:
            flags = 0 if self.case_sensitive else re.IGNORECASE
            return bool(re.match(comparison_value, str(field_value), flags))

        # Collection operations
        elif op == ConditionOperator.IN:
            return field_value in comparison_value
        elif op == ConditionOperator.NOT_IN:
            return field_value not in comparison_value

        # Empty checks
        elif op == ConditionOperator.IS_EMPTY:
            if hasattr(field_value, '__len__'):
                return len(field_value) == 0
            return not field_value
        elif op == ConditionOperator.IS_NOT_EMPTY:
            if hasattr(field_value, '__len__'):
                return len(field_value) > 0
            return bool(field_value)

        # Date operations
        elif op in [ConditionOperator.DATE_BEFORE, ConditionOperator.DATE_AFTER,
                    ConditionOperator.DATE_BETWEEN]:
            field_date = self._parse_date(field_value)
            comp_date = self._parse_date(comparison_value)

            if op == ConditionOperator.DATE_BEFORE:
                return field_date < comp_date
            elif op == ConditionOperator.DATE_AFTER:
                return field_date > comp_date
            elif op == ConditionOperator.DATE_BETWEEN:
                start_date, end_date = comparison_value
                return self._parse_date(start_date) <= field_date <= self._parse_date(end_date)

        # Age operations
        elif op in [ConditionOperator.AGE_GREATER_THAN, ConditionOperator.AGE_LESS_THAN]:
            if isinstance(field_value, (date, datetime)):
                age = self._calculate_age(field_value)
                if op == ConditionOperator.AGE_GREATER_THAN:
                    return age > comparison_value
                else:
                    return age < comparison_value

        # Comparison operations
        else:
            ops = {
                ConditionOperator.EQUALS: operator.eq,
                ConditionOperator.NOT_EQUALS: operator.ne,
                ConditionOperator.GREATER_THAN: operator.gt,
                ConditionOperator.GREATER_THAN_OR_EQUAL: operator.ge,
                ConditionOperator.LESS_THAN: operator.lt,
                ConditionOperator.LESS_THAN_OR_EQUAL: operator.le,
            }

            if op in ops:
                return ops[op](field_value, comparison_value)

        return False

    def _parse_date(self, value: Any) -> date:
        """Parse value to date."""
        if isinstance(value, datetime):
            return value.date()
        elif isinstance(value, date):
            return value
        elif isinstance(value, str):
            try:
                return datetime.fromisoformat(value).date()
            except:
                return datetime.strptime(value, "%Y-%m-%d").date()
        else:
            raise ValueError(f"Cannot parse date from {value}")

    def _calculate_age(self, birth_date: Union[date, datetime]) -> int:
        """Calculate age from birth date."""
        if isinstance(birth_date, datetime):
            birth_date = birth_date.date()

        today = timezone.now().date()
        age = today.year - birth_date.year

        if today.month < birth_date.month or (today.month == birth_date.month and today.day < birth_date.day):
            age -= 1

        return age


@dataclass
class ConditionGroup:
    """Group of conditions with logical operator."""
    operator: ConditionOperator  # AND, OR, NOT
    conditions: List[Union[Condition, 'ConditionGroup']]

    def evaluate(self, context: Dict[str, Any]) -> bool:
        """Evaluate condition group."""
        if self.operator == ConditionOperator.AND:
            return all(cond.evaluate(context) for cond in self.conditions)
        elif self.operator == ConditionOperator.OR:
            return any(cond.evaluate(context) for cond in self.conditions)
        elif self.operator == ConditionOperator.NOT:
            # NOT operates on first condition only
            return not self.conditions[0].evaluate(context) if self.conditions else True
        else:
            raise ValueError(f"Invalid logical operator: {self.operator}")


class ConditionBuilder:
    """Builder for creating complex conditions."""

    def __init__(self):
        self.conditions: List[Union[Condition, ConditionGroup]] = []
        self.current_group: Optional[ConditionGroup] = None

    def add_condition(self, field: str, operator: Union[str, ConditionOperator], value: Any, **kwargs) -> 'ConditionBuilder':
        """Add a condition."""
        if isinstance(operator, str):
            operator = ConditionOperator(operator)

        condition = Condition(field, operator, value, **kwargs)

        if self.current_group:
            self.current_group.conditions.append(condition)
        else:
            self.conditions.append(condition)

        return self

    def and_(self) -> 'ConditionBuilder':
        """Start AND group."""
        group = ConditionGroup(ConditionOperator.AND, [])

        if self.current_group:
            self.current_group.conditions.append(group)
        else:
            self.conditions.append(group)

        self.current_group = group
        return self

    def or_(self) -> 'ConditionBuilder':
        """Start OR group."""
        group = ConditionGroup(ConditionOperator.OR, [])

        if self.current_group:
            self.current_group.conditions.append(group)
        else:
            self.conditions.append(group)

        self.current_group = group
        return self

    def not_(self) -> 'ConditionBuilder':
        """Start NOT group."""
        group = ConditionGroup(ConditionOperator.NOT, [])

        if self.current_group:
            self.current_group.conditions.append(group)
        else:
            self.conditions.append(group)

        self.current_group = group
        return self

    def end_group(self) -> 'ConditionBuilder':
        """End current group."""
        self.current_group = None
        return self

    def build(self) -> Union[Condition, ConditionGroup]:
        """Build final condition."""
        if len(self.conditions) == 1:
            return self.conditions[0]
        else:
            return ConditionGroup(ConditionOperator.AND, self.conditions)


# Predefined conditions
{% for model in models %}
{% if model.rules %}
# {{ model.name }} conditions
{% for rule in model.rules %}
{% if rule.conditions %}
def {{ rule.name }}_condition(instance: '{{ model.name }}', context: Dict[str, Any]) -> bool:
    """{{ rule.description }}"""
    builder = ConditionBuilder()

    {% for condition in rule.conditions %}
    {% if condition.group_start %}
    builder.{{ condition.group_start }}()
    {% endif %}

    builder.add_condition(
        field="{{ condition.field }}",
        operator=ConditionOperator.{{ condition.operator|upper }},
        value={{ condition.value|repr }},
        {% if condition.case_sensitive is defined %}case_sensitive={{ condition.case_sensitive }},{% endif %}
        {% if condition.negate is defined %}negate={{ condition.negate }},{% endif %}
    )

    {% if condition.group_end %}
    builder.end_group()
    {% endif %}
    {% endfor %}

    condition = builder.build()
    return condition.evaluate({
        'instance': instance,
        **context
    })


{% endif %}
{% endfor %}
{% endif %}
{% endfor %}

# Utility functions
def evaluate_conditions(conditions: List[Dict[str, Any]], context: Dict[str, Any]) -> bool:
    """Evaluate a list of condition definitions."""
    builder = ConditionBuilder()

    for cond_def in conditions:
        if 'group' in cond_def:
            if cond_def['group'] == 'and':
                builder.and_()
            elif cond_def['group'] == 'or':
                builder.or_()
            elif cond_def['group'] == 'not':
                builder.not_()
            elif cond_def['group'] == 'end':
                builder.end_group()
        else:
            builder.add_condition(
                field=cond_def['field'],
                operator=ConditionOperator(cond_def['operator']),
                value=cond_def['value'],
                **{k: v for k, v in cond_def.items() if k not in ['field', 'operator', 'value']}
            )

    condition = builder.build()
    return condition.evaluate(context)


def create_condition_from_dict(data: Dict[str, Any]) -> Union[Condition, ConditionGroup]:
    """Create condition from dictionary definition."""
    if 'operator' in data and data['operator'] in ['and', 'or', 'not']:
        # It's a group
        return ConditionGroup(
            operator=ConditionOperator(data['operator']),
            conditions=[create_condition_from_dict(c) for c in data['conditions']]
        )
    else:
        # It's a simple condition
        return Condition(
            field=data['field'],
            operator=ConditionOperator(data['operator']),
            value=data['value'],
            **{k: v for k, v in data.items() if k not in ['field', 'operator', 'value']}
        )