"""
Event subscribers for {{ app_name }} app.

Generated by Django Enhanced Generator on {{ now().strftime('%Y-%m-%d %H:%M:%S') }}.
"""
import logging
from typing import Any, Dict, Optional, List
from django.dispatch import receiver
from django.db.models.signals import post_save, pre_save, post_delete, m2m_changed
from django.core.signals import request_finished
from django.contrib.auth import get_user_model
from django.contrib.contenttypes.models import ContentType
from django.utils import timezone
from django.db import transaction
from django.core.cache import cache
{% if features.celery %}
from celery import shared_task
{% endif %}
{% if features.channels %}
from channels.layers import get_channel_layer
from asgiref.sync import async_to_sync
{% endif %}

# Local imports
{% for model in models %}
from ..models import {{ model.name }}
{% endfor %}

logger = logging.getLogger(__name__)
User = get_user_model()
{% if features.channels %}
channel_layer = get_channel_layer()
{% endif %}


class EventSubscriber:
    """Base class for event subscribers."""

    def __init__(self, sender, instance, **kwargs):
        self.sender = sender
        self.instance = instance
        self.kwargs = kwargs
        self.created = kwargs.get('created', False)
        self.user = getattr(instance, '_current_user', None)

    def handle(self):
        """Handle the event."""
        raise NotImplementedError

    def should_process(self) -> bool:
        """Determine if event should be processed."""
        return True

    def get_event_data(self) -> Dict[str, Any]:
        """Get event data for logging/broadcasting."""
        return {
            'model': self.sender.__name__,
            'instance_id': self.instance.pk,
            'event_type': 'created' if self.created else 'updated',
            'timestamp': timezone.now().isoformat(),
            'user_id': self.user.pk if self.user else None,
        }


{% for model in models %}
{% if model.events %}
# {{ model.name }} Event Subscribers
{% for event in model.events %}
class {{ model.name }}{{ event.name }}Subscriber(EventSubscriber):
    """Subscriber for {{ model.name }} {{ event.name }} event."""

    def should_process(self) -> bool:
        """Check if event should be processed."""
        {% if event.conditions %}
        # Check event conditions
        {% for condition in event.conditions %}
        if not ({{ condition }}):
            return False
        {% endfor %}
        {% endif %}
        return True

    def handle(self):
        """Handle {{ event.name }} event."""
        if not self.should_process():
            return

        event_data = self.get_event_data()
        event_data['event_name'] = '{{ event.name }}'

        {% if event.actions %}
        # Execute event actions
        {% for action in event.actions %}
        {% if action.type == 'log' %}
        # Log event
        logger.info(
            f"{{ model.name }} {{ event.name }} event: {self.instance}",
            extra=event_data
        )
        {% elif action.type == 'cache_invalidate' %}
        # Invalidate cache
        cache_keys = [
            f"{{ app_name }}:{{ model.name|lower }}:{self.instance.pk}:*",
            f"{{ app_name }}:{{ model.name|lower }}:list:*",
        ]
        for pattern in cache_keys:
            cache.delete_pattern(pattern)
        {% elif action.type == 'broadcast' %}
        # Broadcast event
        {% if features.channels %}
        async_to_sync(channel_layer.group_send)(
            '{{ model.name|lower }}_updates',
            {
                'type': '{{ event.name|lower }}',
                'data': event_data
            }
        )
        {% endif %}
        {% elif action.type == 'celery_task' %}
        # Queue async task
        {% if features.celery %}
        {{ action.task_name }}.delay(self.instance.pk)
        {% endif %}
        {% elif action.type == 'webhook' %}
        # Send webhook
        self._send_webhook(event_data)
        {% elif action.type == 'custom' %}
        # Custom action
    {{ action.implementation|indent(8) }}
    {% endif %}
    {% endfor %}
    {% endif %}

    {% if event.has_webhook %}
    def _send_webhook(self, event_data: Dict[str, Any]):
        """Send webhook for this event."""
        from ..webhooks import send_webhook

        send_webhook(
            event_type='{{ model.name|lower }}.{{ event.name|lower }}',
            data=event_data,
            instance=self.instance
        )
{% endif %}


@receiver({{ event.signal }}, sender={{ model.name }})
def {{ model.name|lower }}_{{ event.name|lower }}_handler(sender, instance, **kwargs):
    """Handle {{ model.name }} {{ event.name }} event."""
    try:
        subscriber = {{ model.name }}{{ event.name }}Subscriber(sender, instance, **kwargs)
        subscriber.handle()
    except Exception as e:
        logger.error(
            f"Error handling {{ model.name }} {{ event.name }} event: {e}",
            exc_info=True
        )


{% endfor %}
{% endif %}
{% endfor %}

# Batch Event Processors
{% if features.batch_processing %}
class BatchEventProcessor:
    """Process events in batches for performance."""

    def __init__(self, model_name: str, event_type: str):
        self.model_name = model_name
        self.event_type = event_type
        self.events: List[Dict[str, Any]] = []
        self.batch_size = 100
        self.flush_interval = 5  # seconds

    def add_event(self, event_data: Dict[str, Any]):
        """Add event to batch."""
        self.events.append(event_data)

        if len(self.events) >= self.batch_size:
            self.flush()

    def flush(self):
        """Process all pending events."""
        if not self.events:
            return

        try:
            self._process_batch(self.events)
            self.events = []
        except Exception as e:
            logger.error(f"Error processing event batch: {e}")

    def _process_batch(self, events: List[Dict[str, Any]]):
        """Process a batch of events."""
        # Implementation depends on requirements
        {% if features.celery %}
        process_event_batch.delay(self.model_name, self.event_type, events)
        {% else %}
        pass
{% endif %}


# Event processors by model
batch_processors = {
    {% for model in models %}
    {% if model.batch_events %}
    '{{ model.name }}': BatchEventProcessor('{{ model.name }}', 'batch'),
    {% endif %}
    {% endfor %}
}
{% endif %}

# Cross-model event handlers
{% if cross_model_events %}
{% for event in cross_model_events %}
@receiver({{ event.signal }}, sender={{ event.sender }})
def {{ event.name }}_handler(sender, instance, **kwargs):
    """{{ event.description }}"""
    try:
    {{ event.implementation|indent(8) }}
    except Exception as e:
        logger.error(f"Error in {{ event.name }} handler: {e}")
{% endfor %}
{% endif %}

# Utility functions
def invalidate_related_caches(instance, related_models: List[str]):
    """Invalidate caches for related models."""
    cache_keys = []

    for model_name in related_models:
        cache_keys.extend([
            f"{{ app_name }}:{model_name.lower()}:list:*",
            f"{{ app_name }}:{model_name.lower()}:*:related:{instance.__class__.__name__.lower()}:{instance.pk}",
        ])

    for pattern in cache_keys:
        cache.delete_pattern(pattern)


def broadcast_to_users(users: List[User], event_type: str, data: Dict[str, Any]):
    """Broadcast event to specific users."""
    {% if features.channels %}
    for user in users:
        async_to_sync(channel_layer.group_send)(
            f"user_{user.pk}_notifications",
            {
                'type': 'notification',
                'event_type': event_type,
                'data': data
            }
        )
    {% else %}
    pass
{% endif %}


{% if features.celery %}
# Celery tasks for async event processing
@shared_task
def process_event_batch(model_name: str, event_type: str, events: List[Dict[str, Any]]):
    """Process a batch of events asynchronously."""
    logger.info(f"Processing {len(events)} {model_name} {event_type} events")

    # Process events
    for event in events:
        try:
            # Process individual event
            pass
        except Exception as e:
            logger.error(f"Error processing event: {e}")


@shared_task
def cleanup_old_events(days: int = 30):
    """Clean up old event logs."""
    cutoff_date = timezone.now() - timezone.timedelta(days=days)

    # Implementation depends on event storage mechanism
    pass
{% endif %}