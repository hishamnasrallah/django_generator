"""
Event handlers for {{ app_name }} app.

Generated by Django Enhanced Generator on {{ now().strftime('%Y-%m-%d %H:%M:%S') }}.
"""
from typing import List, Callable, Dict, Any
from django.dispatch import Signal
from django.db import transaction
import logging

from .events import DomainEvent, {{ models|map(attribute='name')|map('append', 'Created')|join(', ') }}

logger = logging.getLogger(__name__)


class EventHandler:
    """Base class for event handlers."""

    def can_handle(self, event: DomainEvent) -> bool:
        """Check if this handler can process the event."""
        return event.event_type in self.handles_events()

    def handles_events(self) -> List[str]:
        """Return list of event types this handler processes."""
        raise NotImplementedError

    def handle(self, event: DomainEvent) -> None:
        """Handle the event."""
        raise NotImplementedError


{% for model in models %}
class {{ model.name }}EventHandler(EventHandler):
    """Handle {{ model.name }} domain events."""

    def handles_events(self) -> List[str]:
        """Return list of event types this handler processes."""
        return [
            '{{ model.name|lower }}.created',
            '{{ model.name|lower }}.updated',
            '{{ model.name|lower }}.deleted',
            {% if model.state_machine %}
            {% for transition in model.state_machine.transitions %}
            '{{ model.name|lower }}.{{ transition.name }}',
            {% endfor %}
            {% endif %}
        ]

    def handle(self, event: DomainEvent) -> None:
        """Handle {{ model.name }} events."""
        handler_method = getattr(self, f'handle_{event.event_type.replace(".", "_")}', None)

        if handler_method:
            handler_method(event)
        else:
            logger.warning(f"No handler for event type: {event.event_type}")

    def handle_{{ model.name|lower }}_created(self, event: DomainEvent) -> None:
        """Handle {{ model.name }} created event."""
        logger.info(f"{{ model.name }} created: {event.aggregate_id}")

        # Example: Send notification
        {% if has_notifications %}
        from apps.notifications.services import NotificationService
        NotificationService.send_notification(
            event_type='{{ model.name|lower }}_created',
            user_id=event.user_id,
            data={'{{ model.name|lower }}_id': event.aggregate_id}
        )
        {% endif %}

        # Example: Update search index
        {% if features.performance.elasticsearch %}
        from apps.{{ app_name }}.models import {{ model.name }}
        try:
            instance = {{ model.name }}.objects.get(pk=event.aggregate_id)
            instance.update_search_index()
        except {{ model.name }}.DoesNotExist:
            logger.error(f"{{ model.name }} not found: {event.aggregate_id}")
    {% endif %}

    def handle_{{ model.name|lower }}_updated(self, event: DomainEvent) -> None:
        """Handle {{ model.name }} updated event."""
        logger.info(f"{{ model.name }} updated: {event.aggregate_id}")

        # Example: Clear cache
        from django.core.cache import cache
        cache.delete(f'{{ model.name|lower }}:{event.aggregate_id}')

        # Example: Track changes
        {% if features.enterprise.audit %}
        from apps.audit.models import ChangeLog
        ChangeLog.objects.create(
            model_name='{{ model.name }}',
            object_id=event.aggregate_id,
            user_id=event.user_id,
            changes=event.changes,
            timestamp=event.timestamp
        )
    {% endif %}

    def handle_{{ model.name|lower }}_deleted(self, event: DomainEvent) -> None:
        """Handle {{ model.name }} deleted event."""
        logger.info(f"{{ model.name }} deleted: {event.aggregate_id}")

        # Example: Clean up related data
        # Add cleanup logic here

    {% if model.state_machine %}
    {% for transition in model.state_machine.transitions %}
    def handle_{{ model.name|lower }}_{{ transition.name }}(self, event: DomainEvent) -> None:
        """Handle {{ model.name }} {{ transition.name }} transition."""
        logger.info(
            f"{{ model.name }} {event.aggregate_id} transitioned from "
            f"{event.from_state} to {event.to_state}"
        )

        # Add transition-specific logic here
{% if transition.side_effects %}
{{ transition.side_effects|indent(8) }}
{% endif %}

{% endfor %}
{% endif %}


{% endfor %}

class EventBus:
    """Simple event bus for publishing and subscribing to events."""

    def __init__(self):
        self.handlers: List[EventHandler] = []
        self._signal = Signal()

    def register_handler(self, handler: EventHandler) -> None:
        """Register an event handler."""
        self.handlers.append(handler)
        logger.info(f"Registered handler: {handler.__class__.__name__}")

    def publish(self, event: DomainEvent) -> None:
        """Publish an event to all registered handlers."""
        logger.debug(f"Publishing event: {event.event_type} ({event.event_id})")

        # Send Django signal
        self._signal.send(
            sender=self.__class__,
            event=event
        )

        # Process with registered handlers
        for handler in self.handlers:
            if handler.can_handle(event):
                try:
                    handler.handle(event)
                except Exception as e:
                    logger.error(
                        f"Handler {handler.__class__.__name__} failed to process "
                        f"event {event.event_type}: {e}"
                    )

    def publish_async(self, event: DomainEvent) -> None:
        """Publish event asynchronously using Celery."""
        from .tasks import process_event_async
        process_event_async.delay(event.to_dict())


# Global event bus instance
event_bus = EventBus()

# Register handlers
{% for model in models %}
event_bus.register_handler({{ model.name }}EventHandler())
{% endfor %}


# Decorator for transactional event publishing
def publish_on_commit(*event_types):
    """Decorator to publish events after database commit."""
    def decorator(func):
        def wrapper(*args, **kwargs):
            events_to_publish = []

            # Store events in context
            def publish_event(event):
                events_to_publish.append(event)

            # Replace publish method temporarily
            original_publish = event_bus.publish
            event_bus.publish = publish_event

            try:
                # Execute function
                result = func(*args, **kwargs)

                # Publish events after commit
                transaction.on_commit(
                    lambda: [original_publish(event) for event in events_to_publish]
                )

                return result

            finally:
                # Restore original publish method
                event_bus.publish = original_publish

        return wrapper
    return decorator


# Integration with model signals
from django.db.models.signals import post_save, post_delete
from django.dispatch import receiver

{% for model in models %}
@receiver(post_save, sender='{{ app_name }}.{{ model.name }}')
def publish_{{ model.name|lower }}_saved(sender, instance, created, **kwargs):
    """Publish event when {{ model.name }} is saved."""
    if created:
        event = {{ model.name }}Created(
            {{ model.name|lower }}_id=str(instance.pk),
            user_id=getattr(instance, '_current_user_id', None)
        )
    else:
        # Track changes
        changes = {}
        if instance._state.db and instance.pk:
            old_instance = sender.objects.get(pk=instance.pk)
            for field in instance._meta.fields:
                old_value = getattr(old_instance, field.name)
                new_value = getattr(instance, field.name)
                if old_value != new_value:
                    changes[field.name] = {
                        'old': str(old_value),
                        'new': str(new_value)
                    }

        event = {{ model.name }}Updated(
            {{ model.name|lower }}_id=str(instance.pk),
            changes=changes,
            user_id=getattr(instance, '_current_user_id', None)
        )

    event_bus.publish(event)


@receiver(post_delete, sender='{{ app_name }}.{{ model.name }}')
def publish_{{ model.name|lower }}_deleted(sender, instance, **kwargs):
    """Publish event when {{ model.name }} is deleted."""
    event = {{ model.name }}Deleted(
        {{ model.name|lower }}_id=str(instance.pk),
        user_id=getattr(instance, '_current_user_id', None)
    )

    event_bus.publish(event)


{% endfor %}