"""
Data Transfer Objects (DTOs) for {{ app_name }} app.

Generated by Django Enhanced Generator on {{ now().strftime('%Y-%m-%d %H:%M:%S') }}.
"""
from dataclasses import dataclass, field, asdict
from typing import Optional, List, Dict, Any, Union
from datetime import datetime, date
from decimal import Decimal
from enum import Enum
import json

# Base DTOs
@dataclass
class BaseDTO:
    """Base class for all DTOs."""

    def to_dict(self) -> Dict[str, Any]:
        """Convert DTO to dictionary."""
        return asdict(self)

    def to_json(self) -> str:
        """Convert DTO to JSON string."""
        return json.dumps(self.to_dict(), default=str)

    @classmethod
    def from_dict(cls, data: Dict[str, Any]):
        """Create DTO from dictionary."""
        return cls(**data)

    def validate(self) -> List[str]:
        """Validate DTO data."""
        errors = []
        # Override in subclasses
        return errors


@dataclass
class PaginationDTO(BaseDTO):
    """DTO for pagination parameters."""
    page: int = 1
    page_size: int = 20
    total_count: Optional[int] = None
    total_pages: Optional[int] = None

    def validate(self) -> List[str]:
        errors = []
        if self.page < 1:
            errors.append("Page must be >= 1")
        if self.page_size < 1 or self.page_size > 100:
            errors.append("Page size must be between 1 and 100")
        return errors


@dataclass
class FilterDTO(BaseDTO):
    """Base DTO for filter parameters."""
    search: Optional[str] = None
    ordering: Optional[str] = None
    filters: Dict[str, Any] = field(default_factory=dict)


@dataclass
class ResponseDTO(BaseDTO):
    """Base DTO for API responses."""
    success: bool
    message: Optional[str] = None
    data: Optional[Any] = None
    errors: Optional[List[str]] = None
    metadata: Dict[str, Any] = field(default_factory=dict)


# Model-specific DTOs
{% for model in models %}
{% if model.services %}
# {{ model.name }} DTOs
@dataclass
class {{ model.name }}CreateDTO(BaseDTO):
    """DTO for creating {{ model.name }}."""
    {% for field in model.fields %}
    {% if not field.auto_now and not field.auto_now_add and field.name not in ['id', 'created_by', 'updated_by'] %}
    {{ field.name }}: {{ field|python_type }}{% if not field.required %} = None{% endif %}
    {% endif %}
    {% endfor %}

    def validate(self) -> List[str]:
        errors = []
        {% for field in model.fields %}
        {% if field.required and field.name not in ['id', 'created_at', 'updated_at', 'created_by', 'updated_by'] %}
        if self.{{ field.name }} is None:
            errors.append("{{ field.name }} is required")
        {% endif %}
        {% if field.validators %}
        # Validate {{ field.name }}
        {% for validator in field.validators %}
        {{ validator.implementation|indent(8) }}
        {% endfor %}
        {% endif %}
        {% endfor %}
        return errors


@dataclass
class {{ model.name }}UpdateDTO(BaseDTO):
    """DTO for updating {{ model.name }}."""
    {% for field in model.fields %}
    {% if not field.auto_now and not field.auto_now_add and field.name not in ['id', 'created_at', 'created_by', 'updated_by'] %}
    {{ field.name }}: Optional[{{ field|python_type }}] = None
    {% endif %}
    {% endfor %}

    def has_changes(self) -> bool:
        """Check if any fields have been set."""
        return any(
            getattr(self, field.name) is not None
            for field in self.__dataclass_fields__.values()
        )


@dataclass
class {{ model.name }}DetailDTO(BaseDTO):
    """DTO for {{ model.name }} details."""
    id: int
    {% for field in model.fields %}
    {{ field.name }}: {{ field|python_type }}{% if not field.required %} = None{% endif %}
    {% endfor %}
    {% if model.relationships %}
    # Related data
    {% for rel in model.relationships %}
    {{ rel.name }}: Optional[{% if rel.many %}List[{{ rel.related_model }}DetailDTO]{% else %}{{ rel.related_model }}DetailDTO{% endif %}] = None
    {% endfor %}
    {% endif %}

    @classmethod
    def from_model(cls, instance, include_related: bool = False):
        """Create DTO from model instance."""
        data = {
            'id': instance.pk,
            {% for field in model.fields %}
            '{{ field.name }}': getattr(instance, '{{ field.name }}', None),
            {% endfor %}
        }

        {% if model.relationships %}
        if include_related:
        {% for rel in model.relationships %}
            # Include {{ rel.name }}
            {% if rel.many %}
            data['{{ rel.name }}'] = [
                {{ rel.related_model }}DetailDTO.from_model(item)
                for item in instance.{{ rel.name }}.all()
            ]
            {% else %}
            if hasattr(instance, '{{ rel.name }}') and instance.{{ rel.name }}:
                data['{{ rel.name }}'] = {{ rel.related_model }}DetailDTO.from_model(instance.{{ rel.name }})
        {% endif %}
        {% endfor %}
        {% endif %}

        return cls(**data)


@dataclass
class {{ model.name }}ListDTO(BaseDTO):
    """DTO for {{ model.name }} list items."""
    id: int
    {% for field in model.fields %}
    {% if field.name in model.list_display_fields %}
    {{ field.name }}: {{ field|python_type }}{% if not field.required %} = None{% endif %}
    {% endif %}
    {% endfor %}

    @classmethod
    def from_model(cls, instance):
        """Create DTO from model instance."""
        return cls(
            id=instance.pk,
        {% for field in model.fields %}
        {% if field.name in model.list_display_fields %}
        {{ field.name }}=getattr(instance, '{{ field.name }}', None),
        {% endif %}
        {% endfor %}
        )


    @dataclass
    class {{ model.name }}FilterDTO(FilterDTO):
        """DTO for {{ model.name }} filters."""
        {% for field in model.filterable_fields %}
        {{ field.name }}: Optional[{{ field|python_type }}] = None
        {% if field.type in ['CharField', 'TextField'] %}
        {{ field.name }}__icontains: Optional[str] = None
        {% endif %}
        {% if field.type in ['IntegerField', 'DecimalField', 'FloatField'] %}
        {{ field.name }}__gte: Optional[{{ field|python_type }}] = None
        {{ field.name }}__lte: Optional[{{ field|python_type }}] = None
        {% endif %}
        {% if field.type in ['DateField', 'DateTimeField'] %}
        {{ field.name }}__gte: Optional[{{ field|python_type }}] = None
        {{ field.name }}__lte: Optional[{{ field|python_type }}] = None
    {% endif %}
    {% endfor %}


    {% if model.services.bulk_operations %}
    @dataclass
    class {{ model.name }}BulkOperationDTO(BaseDTO):
        """DTO for bulk operations on {{ model.name }}."""
        ids: List[int]
        operation: str  # 'delete', 'update', 'export'
        data: Optional[Dict[str, Any]] = None

        def validate(self) -> List[str]:
            errors = []
            if not self.ids:
                errors.append("No IDs provided")
            if self.operation not in ['delete', 'update', 'export']:
                errors.append(f"Invalid operation: {self.operation}")
            if self.operation == 'update' and not self.data:
                errors.append("Data required for update operation")
            return errors
    {% endif %}

    {% endif %}
    {% endfor %}

    # Aggregate DTOs
    {% if aggregate_models %}
    {% for aggregate in aggregate_models %}
    @dataclass
    class {{ aggregate.name }}AggregateDTO(BaseDTO):
        """Aggregate DTO for {{ aggregate.description }}."""
        {% for field in aggregate.fields %}
        {{ field.name }}: {{ field.type }}
        {% endfor %}

        @classmethod
        def from_models(cls, {% for model in aggregate.models %}{{ model|lower }}: Optional[Any] = None{% if not loop.last %}, {% endif %}{% endfor %}):
            """Create aggregate DTO from multiple models."""
            return cls(
            {% for field in aggregate.fields %}
            {{ field.name }}={{ field.source }},
            {% endfor %}
            )
        {% endfor %}
        {% endif %}

        # Operation Result DTOs
        @dataclass
        class BulkOperationResultDTO(BaseDTO):
            """DTO for bulk operation results."""
            total: int
            successful: int
            failed: int
            errors: List[Dict[str, Any]] = field(default_factory=list)

            @property
            def success_rate(self) -> float:
                """Calculate success rate."""
                return (self.successful / self.total * 100) if self.total > 0 else 0


        @dataclass
        class ValidationResultDTO(BaseDTO):
            """DTO for validation results."""
            is_valid: bool
            errors: Dict[str, List[str]] = field(default_factory=dict)
            warnings: Dict[str, List[str]] = field(default_factory=dict)

            def add_error(self, field: str, message: str):
                """Add validation error."""
                if field not in self.errors:
                    self.errors[field] = []
                self.errors[field].append(message)
                self.is_valid = False

            def add_warning(self, field: str, message: str):
                """Add validation warning."""
                if field not in self.warnings:
                    self.warnings[field] = []
                self.warnings[field].append(message)


        # Service-specific DTOs
        {% if features.notifications %}
        @dataclass
        class NotificationDTO(BaseDTO):
            """DTO for notifications."""
            recipient_id: int
            type: str
            title: str
            message: str
            data: Dict[str, Any] = field(default_factory=dict)
            send_email: bool = False
            send_push: bool = False
        {% endif %}

        {% if features.export %}
        @dataclass
        class ExportRequestDTO(BaseDTO):
            """DTO for export requests."""
            format: str  # 'csv', 'excel', 'json', 'pdf'
            fields: Optional[List[str]] = None
            filters: Optional[Dict[str, Any]] = None
            include_related: bool = False

            def validate(self) -> List[str]:
                errors = []
                if self.format not in ['csv', 'excel', 'json', 'pdf']:
                    errors.append(f"Invalid export format: {self.format}")
                return errors
    {% endif %}