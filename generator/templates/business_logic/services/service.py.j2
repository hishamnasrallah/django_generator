"""
Service layer for {{ app_name }} app.

Generated by Django Enhanced Generator on {{ now().strftime('%Y-%m-%d %H:%M:%S') }}.
"""
from typing import Optional, List, Dict, Any, Tuple
from django.db import transaction
from django.core.exceptions import ValidationError, PermissionDenied
from django.contrib.auth import get_user_model
from django.utils import timezone
from django.core.cache import cache
import logging
{% if features.celery %}
from celery import shared_task
{% endif %}

# Local imports
from .repository import *
from .dto import *
from ..models import *
{% if features.notifications %}
from ..notifications import NotificationService
{% endif %}
{% if features.audit %}
from ..audit import AuditService
{% endif %}

logger = logging.getLogger(__name__)
User = get_user_model()


class BaseService:
    """Base service with common functionality."""

    def __init__(self, user: Optional[User] = None):
        self.user = user
        self.errors: List[str] = []

    def add_error(self, message: str):
        """Add error message."""
        self.errors.append(message)
        logger.error(f"Service error: {message}")

    def has_errors(self) -> bool:
        """Check if service has errors."""
        return bool(self.errors)

    def clear_errors(self):
        """Clear error messages."""
        self.errors = []

    def check_permission(self, permission: str, obj: Optional[Any] = None):
        """Check user permission."""
        if not self.user:
            raise PermissionDenied("Authentication required")

        if not self.user.has_perm(permission, obj):
            raise PermissionDenied(f"Permission denied: {permission}")

    def validate_dto(self, dto: BaseDTO) -> bool:
        """Validate DTO."""
        errors = dto.validate()
        if errors:
            self.errors.extend(errors)
            return False
        return True


{% for model in models %}
{% if model.services %}
class {{ model.name }}Service(BaseService):
    """Service layer for {{ model.name }}."""

    def __init__(self, user: Optional[User] = None):
        super().__init__(user)
        self.repository = {{ model.name }}Repository()
        {% if features.notifications %}
        self.notification_service = NotificationService()
        {% endif %}
        {% if features.audit %}
        self.audit_service = AuditService()
    {% endif %}

    def get_by_id(self, id: int) -> Optional[{{ model.name }}DetailDTO]:
        """Get {{ model.name }} by ID."""
        self.check_permission('{{ app_name }}.view_{{ model.name|lower }}')

        instance = self.repository.get_for_detail_view(id)
        if not instance:
            self.add_error(f"{{ model.name }} with ID {id} not found")
            return None

        return {{ model.name }}DetailDTO.from_model(instance, include_related=True)

    def get_list(self, filter_dto: {{ model.name }}FilterDTO, pagination: PaginationDTO) -> Tuple[List[{{ model.name }}ListDTO], PaginationDTO]:
        """Get paginated list of {{ model.name }}."""
        self.check_permission('{{ app_name }}.view_{{ model.name|lower }}')

        # Build queryset
        qs = self.repository.get_for_list_view()

        # Apply filters
        filter_dict = {k: v for k, v in filter_dto.to_dict().items() if v is not None and k not in ['search', 'ordering', 'filters']}
        if filter_dict:
            qs = qs.filter(**filter_dict)

        # Apply search
        if filter_dto.search:
            qs = self.repository.search(filter_dto.search)

        # Apply ordering
        if filter_dto.ordering:
            qs = qs.order_by(filter_dto.ordering)

        # Get total count
        total_count = qs.count()

        # Apply pagination
        offset = (pagination.page - 1) * pagination.page_size
        limit = offset + pagination.page_size
        items = qs[offset:limit]

        # Convert to DTOs
        dto_list = [{{ model.name }}ListDTO.from_model(item) for item in items]

        # Update pagination info
        pagination.total_count = total_count
        pagination.total_pages = (total_count + pagination.page_size - 1) // pagination.page_size

        return dto_list, pagination

    @transaction.atomic
    def create(self, create_dto: {{ model.name }}CreateDTO) -> Optional[{{ model.name }}DetailDTO]:
        """Create new {{ model.name }}."""
        self.check_permission('{{ app_name }}.add_{{ model.name|lower }}')

        if not self.validate_dto(create_dto):
            return None

        try:
            # Prepare data
            data = create_dto.to_dict()
            {% if model.features.audit %}
            data['created_by'] = self.user
            {% endif %}

            # Create instance
            instance = self.repository.create(**data)

            {% if features.notifications %}
            # Send notification
            self.notification_service.send_notification(
                'new_{{ model.name|lower }}',
                {'instance': instance, 'user': self.user}
            )
            {% endif %}

            {% if features.audit %}
            # Log audit
            self.audit_service.log_action(
                user=self.user,
                action='create',
                model=instance.__class__.__name__,
                object_id=instance.pk,
                data=data
            )
            {% endif %}

            return {{ model.name }}DetailDTO.from_model(instance)

        except Exception as e:
            logger.error(f"Error creating {{ model.name }}: {e}")
            self.add_error(f"Failed to create {{ model.name }}: {str(e)}")
            raise

    @transaction.atomic
    def update(self, id: int, update_dto: {{ model.name }}UpdateDTO) -> Optional[{{ model.name }}DetailDTO]:
        """Update existing {{ model.name }}."""
        self.check_permission('{{ app_name }}.change_{{ model.name|lower }}')

        if not update_dto.has_changes():
            self.add_error("No changes provided")
            return None

        if not self.validate_dto(update_dto):
            return None

        try:
            # Get instance
            instance = self.repository.get_by_id(id)
            if not instance:
                self.add_error(f"{{ model.name }} with ID {id} not found")
                return None

            # Check object-level permission
            self.check_permission('{{ app_name }}.change_{{ model.name|lower }}', instance)

            # Prepare update data
            update_data = {k: v for k, v in update_dto.to_dict().items() if v is not None}
            {% if model.features.audit %}
            update_data['updated_by'] = self.user
            {% endif %}

            # Store old values for audit
            {% if features.audit %}
            old_values = {k: getattr(instance, k) for k in update_data.keys()}
            {% endif %}

            # Update instance
            for key, value in update_data.items():
                setattr(instance, key, value)
            instance.save()

            {% if features.audit %}
            # Log audit
            self.audit_service.log_action(
                user=self.user,
                action='update',
                model=instance.__class__.__name__,
                object_id=instance.pk,
                data={'old': old_values, 'new': update_data}
            )
            {% endif %}

            return {{ model.name }}DetailDTO.from_model(instance)

        except Exception as e:
            logger.error(f"Error updating {{ model.name }}: {e}")
            self.add_error(f"Failed to update {{ model.name }}: {str(e)}")
            raise

    @transaction.atomic
    def delete(self, id: int) -> bool:
        """Delete {{ model.name }}."""
        self.check_permission('{{ app_name }}.delete_{{ model.name|lower }}')

        try:
            instance = self.repository.get_by_id(id)
            if not instance:
                self.add_error(f"{{ model.name }} with ID {id} not found")
                return False

            # Check object-level permission
            self.check_permission('{{ app_name }}.delete_{{ model.name|lower }}', instance)

            {% if model.features.soft_delete %}
            # Soft delete
            success = self.repository.soft_delete(id)
            {% else %}
            # Hard delete
            success = self.repository.delete(id)
            {% endif %}

            if success:
            {% if features.audit %}
                # Log audit
                self.audit_service.log_action(
                    user=self.user,
                    action='delete',
                    model='{{ model.name }}',
                    object_id=id
                )
            {% endif %}

            return success

        except Exception as e:
            logger.error(f"Error deleting {{ model.name }}: {e}")
            self.add_error(f"Failed to delete {{ model.name }}: {str(e)}")
            raise

    {% if model.services.bulk_operations %}
    def bulk_delete(self, bulk_dto: {{ model.name }}BulkOperationDTO) -> BulkOperationResultDTO:
        """Bulk delete {{ model.name }} instances."""
        self.check_permission('{{ app_name }}.delete_{{ model.name|lower }}')

        if not self.validate_dto(bulk_dto):
            return BulkOperationResultDTO(
                total=len(bulk_dto.ids),
                successful=0,
                failed=len(bulk_dto.ids),
                errors=[{'message': error} for error in self.errors]
            )

        result = BulkOperationResultDTO(
            total=len(bulk_dto.ids),
            successful=0,
            failed=0
        )

        for id in bulk_dto.ids:
            try:
                if self.delete(id):
                    result.successful += 1
                else:
                    result.failed += 1
            except Exception as e:
                result.failed += 1
                result.errors.append({
                    'id': id,
                    'error': str(e)
                })

        return result

    def bulk_update(self, bulk_dto: {{ model.name }}BulkOperationDTO) -> BulkOperationResultDTO:
        """Bulk update {{ model.name }} instances."""
        self.check_permission('{{ app_name }}.change_{{ model.name|lower }}')

        if not self.validate_dto(bulk_dto):
            return BulkOperationResultDTO(
                total=len(bulk_dto.ids),
                successful=0,
                failed=len(bulk_dto.ids),
                errors=[{'message': error} for error in self.errors]
            )

        result = BulkOperationResultDTO(
            total=len(bulk_dto.ids),
            successful=0,
            failed=0
        )

        # Create update DTO from bulk data
        update_dto = {{ model.name }}UpdateDTO(**bulk_dto.data)

        for id in bulk_dto.ids:
            try:
                if self.update(id, update_dto):
                    result.successful += 1
                else:
                    result.failed += 1
            except Exception as e:
                result.failed += 1
                result.errors.append({
                    'id': id,
                    'error': str(e)
                })

        return result
    {% endif %}

    {% for method in model.services.custom_methods %}
    def {{ method.name }}(self, {{ method.params|join(', ') }}) -> {{ method.return_type }}:
        """{{ method.description }}"""
        {% if method.permission %}
        self.check_permission('{{ method.permission }}')
    {% endif %}

    {{ method.implementation|indent(8) }}
    {% endfor %}

    {% if model.state_machine %}
    def transition_state(self, id: int, transition: str, **kwargs) -> bool:
        """Execute state transition."""
        instance = self.repository.get_by_id(id)
        if not instance:
            self.add_error(f"{{ model.name }} with ID {id} not found")
            return False

        # Check if transition is valid
        if not hasattr(instance, transition):
            self.add_error(f"Invalid transition: {transition}")
            return False

        try:
            # Execute transition
            transition_method = getattr(instance, transition)
            transition_method(user=self.user, **kwargs)

            return True

        except Exception as e:
            logger.error(f"State transition failed: {e}")
            self.add_error(f"Transition failed: {str(e)}")
            return False
{% endif %}


{% endif %}
{% endfor %}

# Service Registry
class ServiceRegistry:
    """Registry for all services."""

    _services: Dict[str, BaseService] = {}

    @classmethod
    def register(cls, name: str, service_class: type):
        """Register a service class."""
        cls._services[name] = service_class

    @classmethod
    def get(cls, name: str, user: Optional[User] = None) -> Optional[BaseService]:
        """Get a service instance."""
        service_class = cls._services.get(name)
        if service_class:
            return service_class(user=user)
        return None


# Register all services
{% for model in models %}
{% if model.services %}
ServiceRegistry.register('{{ model.name }}Service', {{ model.name }}Service)
{% endif %}
{% endfor %}

# Service facade
class {{ app_name|title }}ServiceFacade:
    """Facade for all {{ app_name }} services."""

    def __init__(self, user: Optional[User] = None):
        self.user = user
        {% for model in models %}
        {% if model.services %}
        self.{{ model.name|lower }} = {{ model.name }}Service(user)
    {% endif %}
    {% endfor %}

    def get_service(self, name: str) -> Optional[BaseService]:
        """Get service by name."""
        return ServiceRegistry.get(name, self.user)