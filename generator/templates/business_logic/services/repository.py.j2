"""
Repository layer for {{ app_name }} app.

Generated by Django Enhanced Generator on {{ now().strftime('%Y-%m-%d %H:%M:%S') }}.
"""
from typing import Optional, List, Dict, Any, Type, TypeVar, Generic
from django.db.models import QuerySet, Q, F, Count, Sum, Avg, Max, Min
from django.db.models.query import Prefetch
from django.core.exceptions import ObjectDoesNotExist
from django.db import transaction, models
from django.core.cache import cache
from django.utils import timezone
import logging

# Local imports
{% for model in models %}
from ..models import {{ model.name }}
{% endfor %}
from .dto import *

logger = logging.getLogger(__name__)

T = TypeVar('T', bound=models.Model)


class BaseRepository(Generic[T]):
    """Base repository with common database operations."""

    model: Type[T] = None

    def __init__(self):
        if not self.model:
            raise ValueError("Model class must be specified")

    def get_queryset(self) -> QuerySet[T]:
        """Get base queryset."""
        return self.model.objects.all()

    def get_by_id(self, id: int, prefetch_related: List[str] = None, select_related: List[str] = None) -> Optional[T]:
        """Get single instance by ID."""
        try:
            qs = self.get_queryset()

            if select_related:
                qs = qs.select_related(*select_related)
            if prefetch_related:
                qs = qs.prefetch_related(*prefetch_related)

            return qs.get(pk=id)
        except ObjectDoesNotExist:
            return None

    def get_all(self, prefetch_related: List[str] = None, select_related: List[str] = None) -> QuerySet[T]:
        """Get all instances."""
        qs = self.get_queryset()

        if select_related:
            qs = qs.select_related(*select_related)
        if prefetch_related:
            qs = qs.prefetch_related(*prefetch_related)

        return qs

    def filter(self, **kwargs) -> QuerySet[T]:
        """Filter instances."""
        return self.get_queryset().filter(**kwargs)

    def exists(self, **kwargs) -> bool:
        """Check if instances exist."""
        return self.get_queryset().filter(**kwargs).exists()

    def count(self, **kwargs) -> int:
        """Count instances."""
        return self.get_queryset().filter(**kwargs).count()

    def create(self, **kwargs) -> T:
        """Create new instance."""
        return self.model.objects.create(**kwargs)

    def bulk_create(self, instances: List[T], batch_size: int = 100) -> List[T]:
        """Bulk create instances."""
        return self.model.objects.bulk_create(instances, batch_size=batch_size)

    def update(self, id: int, **kwargs) -> Optional[T]:
        """Update instance."""
        instance = self.get_by_id(id)
        if instance:
            for key, value in kwargs.items():
                setattr(instance, key, value)
            instance.save()
        return instance

    def bulk_update(self, instances: List[T], fields: List[str], batch_size: int = 100) -> None:
        """Bulk update instances."""
        self.model.objects.bulk_update(instances, fields, batch_size=batch_size)

    def delete(self, id: int) -> bool:
        """Delete instance."""
        instance = self.get_by_id(id)
        if instance:
            instance.delete()
            return True
        return False

    def bulk_delete(self, ids: List[int]) -> int:
        """Bulk delete instances."""
        return self.get_queryset().filter(pk__in=ids).delete()[0]

    @transaction.atomic
    def save_or_update(self, defaults: Dict[str, Any], **kwargs) -> tuple[T, bool]:
        """Get or create with update."""
        instance, created = self.model.objects.get_or_create(
            defaults=defaults,
            **kwargs
        )

        if not created and defaults:
            for key, value in defaults.items():
                setattr(instance, key, value)
            instance.save()

        return instance, created


{% for model in models %}
{% if model.repository %}
class {{ model.name }}Repository(BaseRepository[{{ model.name }}]):
    """Repository for {{ model.name }} model."""

    model = {{ model.name }}

    {% if model.repository.cache_enabled %}
    def __init__(self):
        super().__init__()
        self.cache_timeout = {{ model.repository.cache_timeout|default(3600) }}
        self.cache_prefix = "{{ app_name }}:{{ model.name|lower }}"

    def _get_cache_key(self, suffix: str) -> str:
        """Generate cache key."""
        return f"{self.cache_prefix}:{suffix}"

    def _invalidate_cache(self, patterns: List[str] = None):
        """Invalidate cache entries."""
        if not patterns:
            patterns = [f"{self.cache_prefix}:*"]

        for pattern in patterns:
            cache.delete_pattern(pattern)
    {% endif %}

    {% if model.features.soft_delete %}
    def get_queryset(self) -> QuerySet[{{ model.name }}]:
        """Get queryset excluding soft-deleted items."""
        return super().get_queryset().filter(is_deleted=False)

    def get_deleted(self) -> QuerySet[{{ model.name }}]:
        """Get only soft-deleted items."""
        return self.model.objects.filter(is_deleted=True)

    def get_all_with_deleted(self) -> QuerySet[{{ model.name }}]:
        """Get all items including soft-deleted."""
        return self.model.objects.all()

    def soft_delete(self, id: int) -> bool:
        """Soft delete instance."""
        instance = self.get_by_id(id)
        if instance:
            instance.is_deleted = True
            instance.deleted_at = timezone.now()
            instance.save()
            {% if model.repository.cache_enabled %}
            self._invalidate_cache()
            {% endif %}
            return True
        return False

    def restore(self, id: int) -> bool:
        """Restore soft-deleted instance."""
        instance = self.model.objects.filter(pk=id, is_deleted=True).first()
        if instance:
            instance.is_deleted = False
            instance.deleted_at = None
            instance.save()
            {% if model.repository.cache_enabled %}
            self._invalidate_cache()
            {% endif %}
            return True
        return False
    {% endif %}

    {% for method in model.repository.custom_methods %}
    def {{ method.name }}(self, {{ method.params|join(', ') }}) -> {{ method.return_type }}:
        """{{ method.description }}"""
        {% if model.repository.cache_enabled and method.cacheable %}
        cache_key = self._get_cache_key(f"{{ method.name }}:{hash(str(locals()))}")
        result = cache.get(cache_key)

        if result is not None:
            return result
        {% endif %}

        {{ method.implementation|indent(8) }}

        {% if model.repository.cache_enabled and method.cacheable %}
        cache.set(cache_key, result, self.cache_timeout)
        {% endif %}

        return result
    {% endfor %}

    # Query optimization methods
    def get_for_list_view(self) -> QuerySet[{{ model.name }}]:
        """Get optimized queryset for list views."""
        return self.get_queryset(){% if model.list_select_related %}.select_related({{ model.list_select_related|join(', ')|repr }}){% endif %}{% if model.list_prefetch_related %}.prefetch_related({{ model.list_prefetch_related|join(', ')|repr }}){% endif %}

    def get_for_detail_view(self, id: int) -> Optional[{{ model.name }}]:
        """Get optimized instance for detail view."""
        return self.get_by_id(
            id,
            select_related={{ model.detail_select_related|default([]) }},
            prefetch_related={{ model.detail_prefetch_related|default([]) }}
        )

    # Filtering methods
    def search(self, query: str, fields: List[str] = None) -> QuerySet[{{ model.name }}]:
        """Search across multiple fields."""
        if not query:
            return self.get_queryset().none()

        if not fields:
            fields = {{ model.searchable_fields|default(['name']) }}

        q_objects = Q()
        for field in fields:
            q_objects |= Q(**{f"{field}__icontains": query})

        return self.get_queryset().filter(q_objects)

    def filter_by_date_range(self, field: str, start_date: Optional[datetime] = None, end_date: Optional[datetime] = None) -> QuerySet[{{ model.name }}]:
        """Filter by date range."""
        qs = self.get_queryset()

        if start_date:
            qs = qs.filter(**{f"{field}__gte": start_date})
        if end_date:
            qs = qs.filter(**{f"{field}__lte": end_date})

        return qs

    # Aggregation methods
    def get_statistics(self) -> Dict[str, Any]:
        """Get model statistics."""
        qs = self.get_queryset()

        return {
            'total_count': qs.count(),
            {% for stat in model.statistics %}
            '{{ stat.name }}': qs.aggregate({{ stat.aggregation }})['{{ stat.field }}__{{ stat.function }}'],
            {% endfor %}
            'last_created': qs.order_by('-created_at').first(),
            'last_updated': qs.order_by('-updated_at').first(),
        }

    {% if model.relationships %}
    # Related data methods
    {% for rel in model.relationships %}
    def get_with_{{ rel.name }}(self, id: int) -> Optional[{{ model.name }}]:
        """Get instance with {{ rel.name }} preloaded."""
        return self.get_by_id(
            id,
            {% if rel.type in ['ForeignKey', 'OneToOneField'] %}
            select_related=['{{ rel.name }}']
        {% else %}
        prefetch_related=['{{ rel.name }}']
        {% endif %}
        )
        {% endfor %}
        {% endif %}

        @transaction.atomic
        def create_with_related(self, data: Dict[str, Any], related_data: Dict[str, List[Dict[str, Any]]]) -> {{ model.name }}:
            """Create instance with related objects."""
            # Extract main instance data
            instance = self.create(**data)

            # Create related objects
            {% for rel in model.relationships %}
            {% if rel.reverse and rel.type == 'ForeignKey' %}
            if '{{ rel.related_name }}' in related_data:
                for item_data in related_data['{{ rel.related_name }}']:
                    item_data['{{ rel.field }}'] = instance
                    {{ rel.related_model }}.objects.create(**item_data)
            {% endif %}
            {% endfor %}

            {% if model.repository.cache_enabled %}
            self._invalidate_cache()
            {% endif %}

            return instance


    {% endif %}
    {% endfor %}

    # Repository Registry
    class RepositoryRegistry:
        """Registry for all repositories."""

        _repositories: Dict[str, BaseRepository] = {}

        @classmethod
        def register(cls, name: str, repository: BaseRepository):
            """Register a repository."""
            cls._repositories[name] = repository

        @classmethod
        def get(cls, name: str) -> Optional[BaseRepository]:
            """Get a repository by name."""
            return cls._repositories.get(name)

        @classmethod
        def get_for_model(cls, model: Type[models.Model]) -> Optional[BaseRepository]:
            """Get repository for a model."""
            name = f"{model.__name__}Repository"
            return cls.get(name)


    # Register all repositories
    {% for model in models %}
    {% if model.repository %}
    RepositoryRegistry.register('{{ model.name }}Repository', {{ model.name }}Repository())
    {% endif %}
    {% endfor %}

    # Utility functions
    def get_repository(model_or_name) -> Optional[BaseRepository]:
        """Get repository for model or by name."""
        if isinstance(model_or_name, str):
            return RepositoryRegistry.get(model_or_name)
        elif isinstance(model_or_name, type) and issubclass(model_or_name, models.Model):
            return RepositoryRegistry.get_for_model(model_or_name)
        return None