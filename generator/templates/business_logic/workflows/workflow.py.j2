"""
Workflow definitions for {{ app_name }} app.

Generated by Django Enhanced Generator on {{ now().strftime('%Y-%m-%d %H:%M:%S') }}.
"""
from typing import Dict, List, Any, Optional, Callable
from dataclasses import dataclass, field
from enum import Enum
from django.contrib.auth import get_user_model
from django.utils import timezone
from django.db import transaction
from django.core.exceptions import ValidationError
import logging
{% if features.celery %}
from celery import shared_task, chain, group, chord
{% endif %}

# Local imports
from ..models import *
from .state_machine import StateTransitionManager
from .transitions import TransitionContext, TransitionHook

logger = logging.getLogger(__name__)
User = get_user_model()


class WorkflowStatus(Enum):
    """Workflow execution status."""
    PENDING = "pending"
    RUNNING = "running"
    COMPLETED = "completed"
    FAILED = "failed"
    CANCELLED = "cancelled"
    PAUSED = "paused"


@dataclass
class WorkflowStep:
    """Single step in a workflow."""
    name: str
    description: str
    action: Callable
    condition: Optional[Callable] = None
    on_success: Optional[List[str]] = field(default_factory=list)
    on_failure: Optional[List[str]] = field(default_factory=list)
    retry_count: int = 0
    timeout: Optional[int] = None
    required_permissions: List[str] = field(default_factory=list)
    metadata: Dict[str, Any] = field(default_factory=dict)


@dataclass
class WorkflowContext:
    """Context passed through workflow execution."""
    workflow_id: str
    instance: Any
    user: Optional[User] = None
    data: Dict[str, Any] = field(default_factory=dict)
    errors: List[str] = field(default_factory=list)
    completed_steps: List[str] = field(default_factory=list)
    current_step: Optional[str] = None
    status: WorkflowStatus = WorkflowStatus.PENDING
    started_at: Optional[datetime] = None
    completed_at: Optional[datetime] = None

    def add_error(self, error: str):
        """Add error to context."""
        self.errors.append(error)
        logger.error(f"Workflow {self.workflow_id} error in step {self.current_step}: {error}")

    def mark_step_completed(self, step_name: str):
        """Mark step as completed."""
        self.completed_steps.append(step_name)
        logger.info(f"Workflow {self.workflow_id} completed step: {step_name}")

    def set_status(self, status: WorkflowStatus):
        """Update workflow status."""
        self.status = status
        if status == WorkflowStatus.RUNNING and not self.started_at:
            self.started_at = timezone.now()
        elif status in [WorkflowStatus.COMPLETED, WorkflowStatus.FAILED, WorkflowStatus.CANCELLED]:
            self.completed_at = timezone.now()


class Workflow:
    """Base workflow class."""

    def __init__(self, name: str, description: str):
        self.name = name
        self.description = description
        self.steps: Dict[str, WorkflowStep] = {}
        self.initial_step: Optional[str] = None
        self.hooks: List[TransitionHook] = []

    def add_step(self, step: WorkflowStep, initial: bool = False):
        """Add step to workflow."""
        self.steps[step.name] = step
        if initial:
            self.initial_step = step.name

    def add_hook(self, hook: TransitionHook):
        """Add hook to workflow."""
        self.hooks.append(hook)

    def validate(self) -> List[str]:
        """Validate workflow configuration."""
        errors = []

        if not self.initial_step:
            errors.append("No initial step defined")

        if self.initial_step and self.initial_step not in self.steps:
            errors.append(f"Initial step '{self.initial_step}' not found")

        # Validate step references
        for step_name, step in self.steps.items():
            for next_step in step.on_success + step.on_failure:
                if next_step not in self.steps and next_step != "END":
                    errors.append(f"Step '{step_name}' references unknown step '{next_step}'")

        return errors

    @transaction.atomic
    def execute(self, instance: Any, user: Optional[User] = None, initial_data: Dict[str, Any] = None) -> WorkflowContext:
        """Execute workflow."""
        # Create context
        context = WorkflowContext(
            workflow_id=f"{self.name}_{instance.pk}_{timezone.now().timestamp()}",
            instance=instance,
            user=user,
            data=initial_data or {}
        )

        # Validate workflow
        validation_errors = self.validate()
        if validation_errors:
            for error in validation_errors:
                context.add_error(error)
            context.set_status(WorkflowStatus.FAILED)
            return context

        # Execute workflow
        context.set_status(WorkflowStatus.RUNNING)

        try:
            # Execute pre-workflow hooks
            for hook in self.hooks:
                if hasattr(hook, 'pre_workflow'):
                    hook.pre_workflow(context)

            # Start from initial step
            self._execute_step(self.initial_step, context)

            # Set final status
            if context.errors:
                context.set_status(WorkflowStatus.FAILED)
            else:
                context.set_status(WorkflowStatus.COMPLETED)

            # Execute post-workflow hooks
            for hook in self.hooks:
                if hasattr(hook, 'post_workflow'):
                    hook.post_workflow(context)

        except Exception as e:
            logger.error(f"Workflow {context.workflow_id} failed: {e}")
            context.add_error(str(e))
            context.set_status(WorkflowStatus.FAILED)

        return context

    def _execute_step(self, step_name: str, context: WorkflowContext):
        """Execute a single workflow step."""
        if step_name == "END" or step_name is None:
            return

        step = self.steps.get(step_name)
        if not step:
            context.add_error(f"Step '{step_name}' not found")
            return

        context.current_step = step_name
        logger.info(f"Executing workflow step: {step_name}")

        # Check permissions
        if step.required_permissions and context.user:
            for permission in step.required_permissions:
                if not context.user.has_perm(permission):
                    context.add_error(f"Permission denied: {permission}")
                    return

        # Check condition
        if step.condition:
            try:
                if not step.condition(context):
                    logger.info(f"Step {step_name} condition not met, skipping")
                    # Skip to next steps
                    for next_step in step.on_success:
                        self._execute_step(next_step, context)
                    return
            except Exception as e:
                context.add_error(f"Condition check failed: {e}")
                return

        # Execute action
        success = False
        retry_count = 0

        while retry_count <= step.retry_count:
            try:
                step.action(context)
                success = True
                break
            except Exception as e:
                retry_count += 1
                if retry_count > step.retry_count:
                    context.add_error(f"Step failed after {retry_count} attempts: {e}")
                    break
                else:
                    logger.warning(f"Step {step_name} failed, retrying ({retry_count}/{step.retry_count})")

        # Mark step completed
        if success:
            context.mark_step_completed(step_name)

            # Execute next steps
            for next_step in step.on_success:
                self._execute_step(next_step, context)
        else:
            # Execute failure steps
            for next_step in step.on_failure:
                self._execute_step(next_step, context)


# Predefined workflows
{% for workflow in workflows %}
class {{ workflow.name }}Workflow(Workflow):
    """{{ workflow.description }}"""

    def __init__(self):
        super().__init__("{{ workflow.name }}", "{{ workflow.description }}")

        # Define workflow steps
        {% for step in workflow.steps %}
        self.add_step(
            WorkflowStep(
                name="{{ step.name }}",
                description="{{ step.description }}",
                action=self.{{ step.action }},
                {% if step.condition %}condition=self.{{ step.condition }},{% endif %}
                on_success={{ step.on_success|default([]) }},
                on_failure={{ step.on_failure|default([]) }},
                retry_count={{ step.retry_count|default(0) }},
                {% if step.timeout %}timeout={{ step.timeout }},{% endif %}
                required_permissions={{ step.required_permissions|default([]) }},
            ),
            initial={{ step.initial|default(False) }}
        )
    {% endfor %}

    {% for step in workflow.steps %}
    def {{ step.action }}(self, context: WorkflowContext):
        """{{ step.description }}"""
    {{ step.implementation|indent(8) }}

    {% if step.condition %}
    def {{ step.condition }}(self, context: WorkflowContext) -> bool:
        """Check condition for {{ step.name }}."""
{{ step.condition_implementation|indent(8) }}
{% endif %}
{% endfor %}


{% endfor %}

# Async workflow execution
{% if features.celery %}
@shared_task
def execute_workflow_async(workflow_class_name: str, instance_id: int, model_name: str, user_id: Optional[int] = None, initial_data: Dict[str, Any] = None):
    """Execute workflow asynchronously."""
    try:
        # Get workflow class
        workflow_class = globals().get(workflow_class_name)
        if not workflow_class:
            raise ValueError(f"Workflow class '{workflow_class_name}' not found")

        # Get model instance
        model_class = globals().get(model_name)
        if not model_class:
            raise ValueError(f"Model class '{model_name}' not found")

        instance = model_class.objects.get(pk=instance_id)

        # Get user
        user = None
        if user_id:
            user = User.objects.get(pk=user_id)

        # Create and execute workflow
        workflow = workflow_class()
        context = workflow.execute(instance, user, initial_data)

        return {
            'workflow_id': context.workflow_id,
            'status': context.status.value,
            'errors': context.errors,
            'completed_steps': context.completed_steps,
        }

    except Exception as e:
        logger.error(f"Async workflow execution failed: {e}")
        raise


# Workflow chaining
@shared_task
def chain_workflows(workflow_configs: List[Dict[str, Any]]):
    """Execute multiple workflows in sequence."""
    results = []

    for config in workflow_configs:
        result = execute_workflow_async.delay(**config)
        results.append(result.get())  # Wait for completion

        # Check if workflow failed
        if result['status'] == WorkflowStatus.FAILED.value:
            logger.error(f"Workflow chain stopped due to failure in {config['workflow_class_name']}")
            break

    return results
{% endif %}

# Workflow registry
class WorkflowRegistry:
    """Registry for all workflows."""

    _workflows: Dict[str, type] = {}

    @classmethod
    def register(cls, name: str, workflow_class: type):
        """Register a workflow."""
        cls._workflows[name] = workflow_class

    @classmethod
    def get(cls, name: str) -> Optional[type]:
        """Get workflow class by name."""
        return cls._workflows.get(name)

    @classmethod
    def list_workflows(cls) -> List[str]:
        """List all registered workflows."""
        return list(cls._workflows.keys())


# Register workflows
{% for workflow in workflows %}
WorkflowRegistry.register('{{ workflow.name }}', {{ workflow.name }}Workflow)
{% endfor %}