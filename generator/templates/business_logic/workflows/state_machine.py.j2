"""
State machines for {{ app_name }} app.

Generated by Django Enhanced Generator on {{ now().strftime('%Y-%m-%d %H:%M:%S') }}.
"""
from django.db import models
from django.contrib.auth import get_user_model
from django.contrib.contenttypes.models import ContentType
from django.utils import timezone
from django.core.exceptions import ValidationError
from django_fsm import FSMField, transition
from django_fsm.signals import pre_transition, post_transition
import logging

logger = logging.getLogger(__name__)
User = get_user_model()


{% for sm in state_machines %}
class {{ sm.model_name }}StateMachine:
    """
    State machine for {{ sm.model_name }} model.
    
    States: {{ sm.states|map(attribute='value')|join(', ') }}
    Initial state: {{ sm.initial }}
    """
    
    # State choices
    STATES = [
        {% for state in sm.states %}
        ('{{ state.value }}', '{{ state.label }}'),
        {% endfor %}
    ]
    
    # Allowed transitions
    TRANSITIONS = {
        {% for transition in sm.transitions %}
        '{{ transition.name }}': {
            'from': {{ transition.source }},
            'to': '{{ transition.target }}',
            'permission': '{{ transition.permission or '' }}',
        },
        {% endfor %}
    }
    
    @classmethod
    def get_state_field(cls):
        """Get the FSM field for the model."""
        return FSMField(
            default='{{ sm.initial }}',
            choices=cls.STATES,
            verbose_name='Status',
            help_text='Current state of the {{ sm.model_name.lower() }}'
        )
    
    @classmethod
    def validate_transition(cls, from_state, to_state, user=None):
        """
        Validate if a transition is allowed.
        
        Args:
            from_state: Current state
            to_state: Target state
            user: User attempting the transition
            
        Returns:
            bool: True if transition is allowed
            
        Raises:
            ValidationError: If transition is not allowed
        """
        # Find the transition
        transition_name = None
        for name, config in cls.TRANSITIONS.items():
            if to_state == config['to'] and from_state in config['from']:
                transition_name = name
                break
        
        if not transition_name:
            raise ValidationError(
                f"Transition from {from_state} to {to_state} is not allowed"
            )
        
        # Check permissions
        permission = cls.TRANSITIONS[transition_name]['permission']
        if permission and user and not user.has_perm(permission):
            raise ValidationError(
                f"User does not have permission '{permission}' for this transition"
            )
        
        return True
    
    @classmethod
    def get_available_transitions(cls, current_state, user=None):
        """
        Get available transitions from current state.
        
        Args:
            current_state: Current state
            user: User to check permissions for
            
        Returns:
            List[Dict]: Available transitions
        """
        available = []
        
        for name, config in cls.TRANSITIONS.items():
            if current_state in config['from']:
                # Check permissions
                if config['permission'] and user and not user.has_perm(config['permission']):
                    continue
                
                available.append({
                    'name': name,
                    'target': config['to'],
                    'permission': config['permission'],
                })
        
        return available


{% for transition in sm.transitions %}
# Transition: {{ transition.name }}
def {{ transition.name }}_transition(sender, instance, name, source, target, **kwargs):
    """Handle {{ transition.name }} transition."""
    user = kwargs.get('user')
    
    {% if transition.pre_logic %}
    # Pre-transition logic
    {{ transition.pre_logic|indent(4) }}
    {% endif %}
    
    {% if sm.logging %}
    # Log transition
    StateTransitionLog.objects.create(
        content_type=ContentType.objects.get_for_model(instance),
        object_id=instance.pk,
        transition_name=name,
        from_state=source,
        to_state=target,
        user=user,
        timestamp=timezone.now()
    )
    {% endif %}
    
    logger.info(
        f"{{ sm.model_name }} {instance.pk} transitioned from {source} to {target} "
        f"via {name} by {user or 'system'}"
    )

# Connect transition signal
post_transition.connect(
    {{ transition.name }}_transition,
    sender={{ sm.model_name }},
    dispatch_uid='{{ sm.model_name.lower() }}_{{ transition.name }}_transition'
)

{% endfor %}
{% endfor %}

{% if state_machines and state_machines[0].logging %}
class StateTransitionLog(models.Model):
    """Log of state transitions."""
    
    content_type = models.ForeignKey(ContentType, on_delete=models.CASCADE)
    object_id = models.PositiveIntegerField()
    transition_name = models.CharField(max_length=100)
    from_state = models.CharField(max_length=50)
    to_state = models.CharField(max_length=50)
    user = models.ForeignKey(
        User,
        on_delete=models.SET_NULL,
        null=True,
        blank=True
    )
    timestamp = models.DateTimeField(auto_now_add=True)
    metadata = models.JSONField(default=dict, blank=True)
    
    class Meta:
        ordering = ['-timestamp']
        indexes = [
            models.Index(fields=['content_type', 'object_id']),
            models.Index(fields=['timestamp']),
        ]
    
    def __str__(self):
        return f"{self.transition_name}: {self.from_state} -> {self.to_state}"


class StateTransitionManager:
    """Manager for handling state transitions."""
    
    @staticmethod
    def execute_transition(instance, transition_name, user=None, **kwargs):
        """
        Execute a state transition.
        
        Args:
            instance: Model instance
            transition_name: Name of the transition
            user: User executing the transition
            **kwargs: Additional parameters
            
        Returns:
            bool: True if transition was successful
        """
        try:
            # Get the transition method
            transition_method = getattr(instance, transition_name, None)
            if not transition_method:
                raise ValueError(f"Transition '{transition_name}' not found")
            
            # Execute the transition
            transition_method(user=user, **kwargs)
            
            return True
            
        except Exception as e:
            logger.error(
                f"Transition '{transition_name}' failed for "
                f"{instance.__class__.__name__} {instance.pk}: {e}"
            )
            raise
    
    @staticmethod
    def bulk_transition(queryset, transition_name, user=None, **kwargs):
        """
        Execute transition on multiple instances.
        
        Args:
            queryset: QuerySet of instances
            transition_name: Name of the transition
            user: User executing the transition
            **kwargs: Additional parameters
            
        Returns:
            Dict: Results of bulk transition
        """
        results = {
            'success': 0,
            'failed': 0,
            'errors': []
        }
        
        for instance in queryset:
            try:
                StateTransitionManager.execute_transition(
                    instance, transition_name, user, **kwargs
                )
                results['success'] += 1
            except Exception as e:
                results['failed'] += 1
                results['errors'].append({
                    'instance_id': instance.pk,
                    'error': str(e)
                })
        
        return results
{% endif %}