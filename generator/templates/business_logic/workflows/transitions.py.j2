"""
Transition helpers for {{ app_name }} app.

Generated by Django Enhanced Generator on {{ now().strftime('%Y-%m-%d %H:%M:%S') }}.
"""
from django.core.exceptions import ValidationError
from django.contrib.auth import get_user_model
from django.utils import timezone
from typing import Dict, List, Any, Optional
import logging

logger = logging.getLogger(__name__)
User = get_user_model()


class TransitionError(Exception):
    """Raised when a transition fails."""
    pass


class TransitionValidator:
    """Validates state transitions."""
    
    @staticmethod
    def validate_user_permissions(user: User, permission: str) -> bool:
        """Validate user has required permission."""
        if not permission:
            return True
        
        if not user or not user.is_authenticated:
            return False
        
        return user.has_perm(permission)
    
    @staticmethod
    def validate_business_rules(instance, transition_name: str) -> bool:
        """Validate business rules for transition."""
        # Override in subclasses for specific business rules
        return True
    
    @staticmethod
    def validate_timing_constraints(instance, transition_name: str) -> bool:
        """Validate timing constraints for transition."""
        # Example: Can't transition too quickly
        if hasattr(instance, 'updated_at'):
            time_since_update = timezone.now() - instance.updated_at
            if time_since_update.total_seconds() < 60:  # 1 minute cooldown
                return False
        
        return True


class TransitionContext:
    """Context for transition execution."""
    
    def __init__(self, instance, transition_name: str, user: Optional[User] = None, **kwargs):
        self.instance = instance
        self.transition_name = transition_name
        self.user = user
        self.metadata = kwargs
        self.timestamp = timezone.now()
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert context to dictionary."""
        return {
            'instance_id': self.instance.pk,
            'instance_type': self.instance.__class__.__name__,
            'transition_name': self.transition_name,
            'user_id': self.user.pk if self.user else None,
            'timestamp': self.timestamp.isoformat(),
            'metadata': self.metadata,
        }


class TransitionHook:
    """Base class for transition hooks."""
    
    def pre_transition(self, context: TransitionContext) -> bool:
        """
        Execute before transition.
        
        Returns:
            bool: True to continue, False to abort
        """
        return True
    
    def post_transition(self, context: TransitionContext) -> None:
        """Execute after successful transition."""
        pass
    
    def on_transition_error(self, context: TransitionContext, error: Exception) -> None:
        """Execute when transition fails."""
        logger.error(
            f"Transition {context.transition_name} failed: {error}",
            extra=context.to_dict()
        )


class NotificationHook(TransitionHook):
    """Hook for sending notifications on transitions."""
    
    def post_transition(self, context: TransitionContext) -> None:
        """Send notification after transition."""
        from django.core.mail import send_mail
        from django.conf import settings
        
        # Send email notification
        if hasattr(context.instance, 'get_notification_recipients'):
            recipients = context.instance.get_notification_recipients()
            
            if recipients:
                send_mail(
                    subject=f"{context.instance.__class__.__name__} Status Changed",
                    message=f"Status changed to {context.instance.status}",
                    from_email=settings.DEFAULT_FROM_EMAIL,
                    recipient_list=recipients,
                    fail_silently=True
                )


class AuditHook(TransitionHook):
    """Hook for auditing transitions."""
    
    def post_transition(self, context: TransitionContext) -> None:
        """Create audit log entry."""
        from .models import StateTransitionLog
        from django.contrib.contenttypes.models import ContentType
        
        StateTransitionLog.objects.create(
            content_type=ContentType.objects.get_for_model(context.instance),
            object_id=context.instance.pk,
            transition_name=context.transition_name,
            from_state=context.metadata.get('from_state'),
            to_state=context.metadata.get('to_state'),
            user=context.user,
            timestamp=context.timestamp,
            metadata=context.metadata
        )


class CacheInvalidationHook(TransitionHook):
    """Hook for invalidating caches on transitions."""
    
    def post_transition(self, context: TransitionContext) -> None:
        """Invalidate related caches."""
        from django.core.cache import cache
        
        # Invalidate instance cache
        cache_keys = [
            f"{context.instance.__class__.__name__.lower()}:{context.instance.pk}",
            f"{context.instance.__class__.__name__.lower()}:list",
        ]
        
        cache.delete_many(cache_keys)


class TransitionManager:
    """Manages transition execution with hooks."""
    
    def __init__(self):
        self.hooks: List[TransitionHook] = [
            NotificationHook(),
            AuditHook(),
            CacheInvalidationHook(),
        ]
    
    def add_hook(self, hook: TransitionHook) -> None:
        """Add a transition hook."""
        self.hooks.append(hook)
    
    def execute_transition(self, instance, transition_name: str, user: Optional[User] = None, **kwargs) -> bool:
        """
        Execute a transition with hooks.
        
        Args:
            instance: Model instance
            transition_name: Name of the transition
            user: User executing the transition
            **kwargs: Additional parameters
            
        Returns:
            bool: True if transition was successful
        """
        context = TransitionContext(instance, transition_name, user, **kwargs)
        
        try:
            # Execute pre-transition hooks
            for hook in self.hooks:
                if not hook.pre_transition(context):
                    logger.warning(
                        f"Transition {transition_name} aborted by hook {hook.__class__.__name__}",
                        extra=context.to_dict()
                    )
                    return False
            
            # Get current state for context
            current_state = getattr(instance, 'status', None)
            context.metadata['from_state'] = current_state
            
            # Execute the transition
            transition_method = getattr(instance, transition_name)
            transition_method(user=user, **kwargs)
            
            # Update context with new state
            new_state = getattr(instance, 'status', None)
            context.metadata['to_state'] = new_state
            
            # Execute post-transition hooks
            for hook in self.hooks:
                try:
                    hook.post_transition(context)
                except Exception as e:
                    logger.error(
                        f"Post-transition hook {hook.__class__.__name__} failed: {e}",
                        extra=context.to_dict()
                    )
            
            return True
            
        except Exception as e:
            # Execute error hooks
            for hook in self.hooks:
                try:
                    hook.on_transition_error(context, e)
                except Exception as hook_error:
                    logger.error(f"Error hook failed: {hook_error}")
            
            raise TransitionError(f"Transition {transition_name} failed: {e}")


# Global transition manager instance
transition_manager = TransitionManager()


def execute_transition(instance, transition_name: str, user: Optional[User] = None, **kwargs) -> bool:
    """
    Convenience function to execute a transition.
    
    Args:
        instance: Model instance
        transition_name: Name of the transition
        user: User executing the transition
        **kwargs: Additional parameters
        
    Returns:
        bool: True if transition was successful
    """
    return transition_manager.execute_transition(instance, transition_name, user, **kwargs)


def get_available_transitions(instance, user: Optional[User] = None) -> List[Dict[str, Any]]:
    """
    Get available transitions for an instance.
    
    Args:
        instance: Model instance
        user: User to check permissions for
        
    Returns:
        List[Dict]: Available transitions
    """
    if not hasattr(instance, 'get_available_user_state_transitions'):
        return []
    
    return instance.get_available_user_state_transitions(user)


def can_execute_transition(instance, transition_name: str, user: Optional[User] = None) -> bool:
    """
    Check if a transition can be executed.
    
    Args:
        instance: Model instance
        transition_name: Name of the transition
        user: User to check permissions for
        
    Returns:
        bool: True if transition can be executed
    """
    available = get_available_transitions(instance, user)
    return any(t['name'] == transition_name for t in available)