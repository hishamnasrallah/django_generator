"""
Base Permission Classes for {{ project.name }}

Generated by Django Enhanced Generator on {{ now().strftime('%Y-%m-%d %H:%M:%S') }}.
"""
from rest_framework import permissions
from django.contrib.auth.mixins import PermissionRequiredMixin as DjangoPermissionRequiredMixin
from django.core.exceptions import PermissionDenied


class IsOwner(permissions.BasePermission):
    """Permission to only allow owners of an object to edit it."""

    def has_object_permission(self, request, view, obj):
        # Read permissions are allowed to any request
        if request.method in permissions.SAFE_METHODS:
            return True

        # Write permissions are only allowed to the owner
        return obj.owner == request.user


class IsOwnerOrReadOnly(permissions.BasePermission):
    """Permission to allow owners to edit, others to read only."""

    def has_object_permission(self, request, view, obj):
        # Read permissions are allowed to any request
        if request.method in permissions.SAFE_METHODS:
            return True

        # Write permissions are only allowed to the owner
        return obj.owner == request.user


class IsStaffOrReadOnly(permissions.BasePermission):
    """Permission to allow staff to edit, others to read only."""

    def has_permission(self, request, view):
        # Read permissions are allowed to any request
        if request.method in permissions.SAFE_METHODS:
            return True

        # Write permissions are only allowed to staff
        return request.user and request.user.is_staff


class HasModelPermission(permissions.BasePermission):
    """Check if user has specific model permission."""

    def get_required_permission(self, method, model_cls):
        """
        Get the required permission based on the HTTP method.
        """
        app_label = model_cls._meta.app_label
        model_name = model_cls._meta.model_name

        if method in permissions.SAFE_METHODS:
            return f'{app_label}.view_{model_name}'
        elif method == 'POST':
            return f'{app_label}.add_{model_name}'
        elif method in ['PUT', 'PATCH']:
            return f'{app_label}.change_{model_name}'
        elif method == 'DELETE':
            return f'{app_label}.delete_{model_name}'
        return None

    def has_permission(self, request, view):
        # Get model class
        if hasattr(view, 'get_queryset'):
            queryset = view.get_queryset()
            model_cls = queryset.model
        elif hasattr(view, 'model'):
            model_cls = view.model
        else:
            return False

        # Get required permission
        perm = self.get_required_permission(request.method, model_cls)

        if perm is None:
            return False

        return request.user.has_perm(perm)


class DynamicPermission(permissions.BasePermission):
    """
    Dynamic permission checking based on view attributes.

    Views can define:
    - permission_classes_by_action: dict mapping actions to permission classes
    - get_permissions: method to dynamically determine permissions
    """

    def has_permission(self, request, view):
        # Check for action-specific permissions
        if hasattr(view, 'permission_classes_by_action'):
            action = getattr(view, 'action', None)
            if action and action in view.permission_classes_by_action:
                permission_classes = view.permission_classes_by_action[action]
                return all(
                    perm().has_permission(request, view)
                    for perm in permission_classes
                )

        # Default to True if no specific permissions defined
        return True

    def has_object_permission(self, request, view, obj):
        # Check for action-specific permissions
        if hasattr(view, 'permission_classes_by_action'):
            action = getattr(view, 'action', None)
            if action and action in view.permission_classes_by_action:
                permission_classes = view.permission_classes_by_action[action]
                return all(
                    perm().has_object_permission(request, view, obj)
                    for perm in permission_classes
                )

        return True


{% if features.authentication.roles %}
class HasRole(permissions.BasePermission):
    """Check if user has a specific role."""

    def __init__(self, role_name=None):
        self.role_name = role_name

    def has_permission(self, request, view):
        if not request.user.is_authenticated:
            return False

        # Get role from view if not provided
        role_name = self.role_name or getattr(view, 'required_role', None)

        if not role_name:
            return True

        return request.user.roles.filter(name=role_name).exists()


class HasAnyRole(permissions.BasePermission):
    """Check if user has any of the specified roles."""

    def __init__(self, role_names=None):
        self.role_names = role_names or []

    def has_permission(self, request, view):
        if not request.user.is_authenticated:
            return False

        # Get roles from view if not provided
        role_names = self.role_names or getattr(view, 'required_roles', [])

        if not role_names:
            return True

        return request.user.roles.filter(name__in=role_names).exists()
{% endif %}


class PermissionRequiredMixin(DjangoPermissionRequiredMixin):
    """Enhanced permission required mixin with better error handling."""

    def handle_no_permission(self):
        if self.request.user.is_authenticated:
            raise PermissionDenied(self.get_permission_denied_message())
        return super().handle_no_permission()

    def get_permission_denied_message(self):
        """Get custom permission denied message."""
        if hasattr(self, 'permission_denied_message'):
            return self.permission_denied_message

        if self.permission_required:
            return f"You don't have permission to access this page. Required: {', '.join(self.permission_required)}"

        return "You don't have permission to access this page."